<html>
  <head>
      <link rel="stylesheet" href="styles.css">
      <title>null</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
      <p id="time">Time:0</p>

      <div  class="main" style="overflow:auto;">&nbsp;
        <div id="events">&nbsp;</div>
      </div>
      <div class="menu" >menu<br/>
        move:
        <div id="move-actions">
        </div>
        Get:
        <div id="get-actions"></div>
        Combat:
        <div id="combat-actions"></div>
        Other:
        <div id="other-actions"></div>
      </div>
              <div id="characters"></div>
      <div class="status">
        status&nbsp;
        <div id="room-line">
          <span id="room-name"></span>
          <span id="room-health"></span>
        </div>
        <div id="pc-status"></div>
        <div id="room-description"></div>
      </div>
  </body>
</html>

<script src="buckets.js"></script>
<script>
"use strict"

/*
TODO:
  miss chance
  wound logs
  show pending action
  acid blood
  all interobject refs through IDs, no references
  replace void room with item/actor/etc. "rooms"
    generic item action code
  ai system
  widgets and service
  split htm and js
  get rid of event log space
  names, like characters -> pcs
  deep copy def obj (?)
  scopable event log
  add 'config' object, mostly for debugging
    disable clicking on dead pc tab
  upside down event log?
  generate js signature docs
  map display
  finish map
  make movie accurate map
  make fan recreation accurate map
  json case insensitive?
  pending action progress bar
fix stupid json error catching code
localization??
*/

const TICK_LENGTH = 1000;
const Actions = {
  MOVE:"move",
  UNLOCK:"unlock",
  ATTACK:"attack",
  GET:"get",
  DROP:"drop",
  USE:"use",
  CAPTURE:"capture" // TODO generic target action
};
const Events = {
  LOG:"log"
};
const Category = {
  DOORS:"doors",
  ITEMS:"items",
  ACTORS:"actors",
  ROOMS:"rooms",
  AI:"ai",
  SPECIAL:"special"
};
const Health = {
  OK:"OK",
  WOUNDED:"wounded",
  DEAD:"dead"
};
const AI_PLAYER = "player";
const DEF_DEFAULT = "default";
const DEF_TYPE = "type";
const SELECTED = "selected";
const MOVE_ACTIONS = "move-actions";
const GET_ACTIONS = "get-actions";
const COMBAT_ACTIONS = "combat-actions";
const OTHER_ACTIONS = "other-actions";
const VOID = "void"; // Room for when need "nowhere"


    function loadJSON(callback) {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', 'http://localhost:8080/nostromo.json', true);
        xobj.onreadystatechange = function () {
            if (xobj.readyState == 4 && xobj.status == "200") {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }


    loadJSON(function(response) {
        let errorPattern = /(\d+).*/g;
        var parsed;
        try {
          parsed = JSON.parse(response);
        } catch (e) {
          if (e instanceof SyntaxError) {
            const grabRadius = 20;
              let message = e.message;
              let matched =  errorPattern.exec(message);
              let pos = matched[1]; // 1st capture
              if (pos) {
                let min = Math.max(0, pos - grabRadius);
                let max = Math.min(response.length - 1, pos + grabRadius);
                let snippet = response.substring(min, max);
                alert( 'Error loading game data JSON: ' + e + '\n\n' + snippet);
              }
          } else {
            alert('Error: ' + e);
          }
          return;
        }
        var gameData = new GameData(parsed);
        init(gameData);
        initUi(gameData);
        setInterval(function () {
            gameLoop(gameData);
        }, TICK_LENGTH);
    });

    function init(gameData) {
      let roomDoorMap = {};
      gameData.rooms.push({id: VOID}); // VOID room, dor taking things out of level
      for (let key in Category ) {
        let category = Category[key];
        let defs = gameData.defs[category];
        let itemDefs = gameData.defs[Category.ITEMS];
        let objects = gameData[category];
        let lookup = {};
        gameData.transient.byId[category] = lookup;

        for (let i in objects) { // Instantiation pass
          objects[i] = TypedClass.create(category, objects[i], defs, i);
          if (lookup[objects[i].id]) {
            throw Error("Dupe id " + objects[i].id);
          }
          lookup[objects[i].id] = objects[i];
          // category specifc
          if (category === Category.DOORS) {
            // Get doors for each room
            let door = objects[i];
            for (let roomName of door.rooms) {
                if (!roomDoorMap.hasOwnProperty(roomName)) {
                    roomDoorMap[roomName] = {
                      id:roomName,
                        doors:[]
                    };
                }
                roomDoorMap[roomName].doors.push(door);
            }
          } else if (category === Category.ROOMS) {
            let room = objects[i];
            let roomItems = room.items;
            for (let j in roomItems) {
              roomItems[j] = TypedClass.create(Category.ITEMS, roomItems[j], itemDefs, j);
            }
          } else if (category === Category.ACTORS) {

          }
        }
      }

      // 2nd passes
      for (let key in roomDoorMap) {
        let doorList = roomDoorMap[key];
        let room = gameData.transient.byId.rooms[key];
        if (!room) {
          // Room mentioned in doors but not defined, create it
          let newRoom = new Room(doorList, gameData.defs[Category.ROOMS]);
          gameData.rooms.push(newRoom);
          gameData.transient.byId.rooms[newRoom.id] = newRoom;
        }
        // Update door list
        gameData.transient.byId.rooms[doorList.id].doors = doorList.doors;
      }

        // TODO check graph connected

        var actors = gameData.actors;
        for (let i in actors) {
          let actor = actors[i];
          if (!gameData.getByCategoryId(Category.ROOMS, actor.roomName)){
             throw new Error("actor location <" + actor.roomName + "> does not exist");
           }
        }

        if (!gameData.scheduler) {
          gameData.scheduler = buckets.PriorityQueue(function(a, b){
              // TODO unit test
              return b.time - a.time;
          });
        } else {
          // TODO
          throw new Error("Scheduler persistence not implemented");
        }

    }

    function gameLoop(gameData) {
        document.getElementById("time").innerHTML = ("Time:" + gameData.time);
        var eventBus = []
        var scheduler = gameData.scheduler;

        // TODO copy gamedata
        // Handle scheduled events
        while (!scheduler.isEmpty() && scheduler.peek().time <= gameData.time) {
            eventBus.push(scheduler.dequeue());
        }
        // check validity *before* resolving any Actions
        eventBus = eventBus.filter(event=>event.isValid(gameData));
        for (let event of eventBus) {
            Action.handleAction(event, gameData);
        }

       // Queue new actions
        for (let actor of gameData.actors) {
          // not preoccupied doing something, being dead or in a box
            if (!gameData.isBusy(actor.id) && actor.isAlive()) {
                var choices = Action.getChoices(actor, gameData);
                // AI actions
                if (actor.ai != AI_PLAYER) {

                    // TODO Specific AIs
                    if (choices.length > 0) {
                      Action.takeAction(actor, choices[Math.floor(Math.random() * choices.length)], gameData); // TODO Types
                    }
                } else {
                     // TODO handle input
                }
            }
        }

        // cull newly invalid actions
        let contents = scheduler.toArray();
        contents = contents.filter((action)=>action.isValid(gameData));
        scheduler.clear();
        for(let action of contents) {
          scheduler.add(action);
        }
        // TODO cleanup, maintenance (?)
       gameData.time = gameData.time + 1;

       draw(gameData);
    }

    function initUi(gameData) {
      // Cache view
      var view = {};
      gameData.transient.view = view;
      view.pcTabs = {};

      // character tabs
      var charTabs = document.getElementById("characters");
      for (let pc of gameData.getPcs()) {
        var newButton = document.createElement("BUTTON");
        newButton.innerHTML = pc.id;
        newButton.onclick=function(){
          selectPc(pc.id, gameData);
          draw(gameData);
        };
        charTabs.appendChild(newButton);
        view.pcTabs[pc.id] = newButton;
      }

      view.menu = {};
      view.menu.moves = document.getElementById(MOVE_ACTIONS);
      view.menu.gets = document.getElementById(GET_ACTIONS);
      view.menu.combat = document.getElementById(COMBAT_ACTIONS);
      view.menu.other = document.getElementById(OTHER_ACTIONS);

      view.status = {}
      view.status.roomName = document.getElementById("room-name");
      view.status.roomHealth = document.getElementById("room-health");
      view.status.pcStatus = document.getElementById("pc-status");
      view.status.roomDescription = document.getElementById("room-description");

      // Validate
      validateView(view);
    }

    function validateView(view) {
      for (let key in view) {
        let subview = view[key];
        if (!subview) {
          throw Error("Empty view handle " + subview);
        }
        for (let subkey in subview) {
          let subsubview = subview[subkey];
          if (!subsubview) {
            throw Error("Empty subview handle " + subview);
          }
        }
      }
    }

    function selectPc(pcId, gameData) {
      let pc = gameData.getByCategoryId(Category.ACTORS, pcId);
      if (pc.ai === AI_PLAYER && pc.isAlive()) {
        gameData.selected = pcId; // TODO rename selectedId
      } else {
        gameData.selected = null;
      }

    }

    function draw(gameData) {
      var view = gameData.transient.view;
      // PC tabs
      for (let pcId in view.pcTabs) {
        var tab = view.pcTabs[pcId];
        if (gameData.selected === pcId) {
          tab.style.color = "green";
        } else {
          tab.style.color = "black";
          if (!gameData.getByCategoryId(Category.ACTORS, pcId).isAlive()) {
            tab.style.opacity = 0.6;
          }
        }
      }

      // menu & status
      let menu = view.menu;
      for(let subview in menu) {
        emptyElem(menu[subview]);
      }
      let status = view.status;
      for (let key in status) {
        emptyElem(status[key]);
      }
      if(gameData.pcSelected()) {
        var pc = gameData.getByCategoryId(Category.ACTORS, gameData.selected);
        var choices = Action.getChoices(pc, gameData);
        // Move actions

        if (!gameData.isBusy(pc.id)) {
          for(let action of choices) {
            var newButton = document.createElement("BUTTON");
            newButton.innerHTML = action.getMenuText();
            newButton.onclick=function(){
              Action.takeAction(pc, action, gameData)
              draw(gameData);
            };
            switch(action.type) {
              case Actions.MOVE:
                view.menu.moves.appendChild(newButton);
                break;
              case Actions.GET:
                view.menu.gets.appendChild(newButton);
                break;
              case Actions.ATTACK:
                view.menu.combat.appendChild(newButton);
                break;
              default:
                view.menu.other.appendChild(newButton);
                break;
            }

          }
        } // else busy

        // status
        let room = gameData.getByCategoryId(Category.ROOMS, pc.roomName);
        view.status.roomName.innerHTML = room.id;
        view.status.roomHealth.innerHTML = room.health + "%";
        let healthText;
        if (pc.hp > pc.health / 2) {
          healthText = "OK";
        } else if (pc.hp > 0) {
          healthText = "wounded";
        } else if (!pc.isAlive()) {
          healthText = "dead";
        } else {
          healthText = "drunk";
        }
        view.status.pcStatus.innerHTML = pc.id + " is " + healthText
            + " and stable."
      }
    }

    function emptyElem(elem) {
      while(elem.hasChildNodes()) {
        elem.removeChild(elem.lastChild);
      }
    }

    class GameData {
      constructor(json) {
        Object.assign(this, json);
        this.transient = {};
        this.transient.byId = {};
      }

      getDefs(defType) {
        if(this.defs.hasOwnProperty(defType)) {
            return this.defs[defType];
        }
        throw Error("No defs type '" + defType + "'.")
      }

      getCategoryMap(category) {
        return this.transient.byId[category];
      }

      getByCategoryId(category, id) {
        return this.transient.byId[category][id];
      }

      getPcs() {
        return this.actors.filter(actor => actor.ai === AI_PLAYER);
      }

      pcSelected() { // TODO selectedId
        return this.selected && this.getByCategoryId(Category.ACTORS, this.selected).isAlive();
      }

      isBusy(actorId) {
        var busyActors = this.scheduler.toArray().map((a)=>a.actor.id); // TODO non-actors
        return busyActors.includes(actorId);
      }
    }

    class Action {
        constructor(type, target, actor) {
          if (!type || !target || !actor)
         {
           throw new Error("type, target, actor must be non null for Action");
         }
            this.type = type;
            this.target = target;
            this.actor = actor;
            this.source = actor.getActionMap()[type];
        }

        static byType(actions) {
          var aggregate = {};
          for (let next of actions){
            if (!next.hasOwnProperty(DEF_TYPE)) {
              throw Error("Typeless action in byType()");
            }
            if(!aggregate.hasOwnProperty(next.type)) {
              aggregate[next.type] = [];
            }
            aggregate[next.type].push(next);
          }
          return aggregate;
        }

        static getChoices(actor, gameData) {
            let out = [];
            let room = gameData.getByCategoryId(Category.ROOMS, actor.roomName);
            let actionMap = actor.getActionMap();
            let addIfSupported = (action)=>{
              if (actionMap[action.type] && action.isValid(gameData)) {
                out.push(action);
              }
            }
            if(room.items && actor.items.length < actor.inventory) {
              let items = room.items;
              for (let item of items) {
                addIfSupported(new Action(Actions.GET, item, actor));
              }
            }
            for (let door of room.doors) {
                if (!door.locked) {
                  addIfSupported(new Action(Actions.MOVE, door.other(room.id), actor));
                } else {
                  // TODO If actor supported
                  addIfSupported(new Action(Actions.UNLOCK, door, actor));
                }
            }
            // Combat
            let actorsHere = [];
            for (let otherActor of gameData.actors ) {
              if (otherActor.roomName === actor.roomName
                  && otherActor.id != actor.id) {
                  addIfSupported(new Action(Actions.ATTACK, otherActor, actor));
                  addIfSupported(new Action(Actions.CAPTURE, otherActor, actor));
              }
            }

            // Items
            if (actor.items) {
              let items = actor.items;
              for (let item of items) {
                // addIfSupported(new Action(Actions.USE, item, actor));
                addIfSupported(new Action(Actions.DROP, item, actor));
              }
            }

            return out;
        }

        static handleAction(event, gameData) {
          // TODO split initiating action into multiple effects
            let actor = event.actor;
            let actorRoom = gameData
                .getByCategoryId(Category.ROOMS, event.actor.roomName);
            let target = event.target;
            if (event.type === Actions.MOVE) {
                event.actor.roomName = event.target;
            } else if (event.type === Actions.UNLOCK) {
                event.target.locked = false;
            } else if (event.type === Actions.ATTACK) {
                let weapon = event.source;
                if (weapon) {
                  target.hp -= weapon.damage;
                  if(!weapon.nobleed) {
                    // TODO bleed
                  }
                }
            } else if (event.type === Actions.GET) {
              let item = event.target;
              actorRoom.items = actorRoom.items.filter((thing)=>thing != item);
                event.actor.items.push(event.target);
            } else if (event.type === Actions.DROP) {
              // Move item to room
              let item = event.target;
              // TODO this
              event.actor.items = event.actor.items.filter((thing)=>thing != item);
              actorRoom.items.push(item);
            } else if (event.type === Actions.USE) {
              // TODO ...use it
            } else if (event.type === Actions.CAPTURE) {
              event.source.captive = target;
              target.roomName = VOID;
              gameData.actors.splice(gameData.actors.indexOf(target));
            }
            var log = document.getElementById("events");
            log.innerHTML= log.innerHTML + (event.getEventText(gameData) + "<br/>");
        }

        static takeAction(actor, action, gameData) { // todo rename queue
            if (action.isValid(gameData)) {
              var length = Action.duration(action, gameData);
              action.time = gameData.time + length;
              gameData.scheduler.enqueue(action);
            } else {
              gameData.scheduler.enqueue(new Action(Events.LOG, "invalid action taken", 0));
            }
        }

        static duration(action, gameData) {
          return 3;
        }

        isValid(gameData) {
          if (!gameData) {throw new Error("NO MORE NULL GAMEDATA");}
          let actor = this.actor;
          let actionMap = actor.getActionMap();
          if (!actionMap[this.type]) {
            return false;
          }
          let target = this.target;
          let actorRoom = gameData
              .getByCategoryId(Category.ROOMS, actor.roomName);
          switch(this.type) {
            case Actions.MOVE: // target=roomName
              return actorRoom.getLinks().includes(target);
            case Actions.UNLOCK: // target=door object
              return target.rooms.includes(actor.roomName);
            case Actions.ATTACK: // actor object
              return actor.roomName === target.roomName && target.attackable
                  && target.isAlive();
            case Actions.CAPTURE: // actor object
              return actor.roomName === target.roomName
                  && target.capturable && !actionMap[this.type].captive;
            case Actions.GET: // room item
              return actorRoom.items.includes(target)
                && actor.items.length < actor.inventory;
            case Actions.DROP: // actor item
              return actor.items.includes(target);
            case Actions.USE:
              return (actorRoom.items.includes(target) || actor.items.includes(target))
                  && target.isUsable();
            case Events.LOG:
              return true;
            default:
              throw new Error("Unsupported action validation: " + this.type);
          }
        }

        getMenuText() {
          // TODO make consistent?
          switch(this.type) {
            case Actions.MOVE:
              return this.target;
            case Actions.UNLOCK:
              return "Unlock Grate"; // TODO localize?
            case Actions.ATTACK:
              return "Attack " + this.target.id;
            case Actions.GET:
              return this.target.type;
            case Actions.DROP:
              return "Drop " + this.target.type;
            case Actions.USE:
              return "Use " + this.target.type;
            case Actions.CAPTURE:
              return "Catch " + this.target.id;
            default:
              throw new Error("Unsupported action text: " + this.type);
          }
        }

        getEventText(gameData) {
            let type = this.type;
            switch(type) {
              case Actions.MOVE:
                return this.actor.id + " moved to " + this.target + ".";
              case Actions.UNLOCK:
                return this.actor.id + " unlocked " + this.target.id + ".";
              case Actions.ATTACK:
                // TODO passive voice?
                return this.actor.id + " attacked " + this.target.id + ".";
              case Actions.GET:
                return this.actor.id + " picked up " + this.target.type + ".";
              case Actions.DROP:
                return this.actor.id + " dropped " + this.target.type + ".";
              case Actions.USE:
                return this.actor.id + " used " + this.target.type + ".";
              case Actions.CAPTURE:
                return this.actor.id + " captured " + this.target.type + ".";
              case Events.LOG:
                // TODO debug flag
                return "Log: " + target;
            }

            return "UNHANDLED EVENT:" + JSON.stringify(event);
        }
    }

    class TypedClass {

        constructor(json, typeDefs, id) {
            // Assign characteristics hierarchically
            this.id = id; // Prefer id from data
            if (typeDefs.hasOwnProperty(DEF_DEFAULT)) {  // Type default
                Object.assign(this, typeDefs[DEF_DEFAULT]);
            }
            if (json.hasOwnProperty(DEF_TYPE)) { // Specific type
                var jsonType = json[DEF_TYPE];
                if (typeDefs.hasOwnProperty(jsonType)) {
                    Object.assign(this, typeDefs[jsonType]);
                } else {
                    throw Error("No defined type: " + jsonType);
                }
            }
            Object.assign(this, json); // Specific instance

            // Validate common properties
            if (!this.id) {
              throw Error("Typed object has no id");
            }
        }

        static create(category, json, def, id) {
          switch(category) {
            case Category.ACTORS:
              return new Actor(json, def, id);
            case Category.DOORS:
              return new Door(json, def, id);
            case Category.ITEMS:
              return new Item(json, def, id);
            case Category.ROOMS:
              return new Room(json, def, id);
            default:
              throw new Error("Unsupported category " + category);
          }
        }
    }

    class Actor extends TypedClass {
      constructor(json, defs) {
        super(json, defs);
        this.category = Category.ACTORS;

        // TODO default or require: inventory, attack
        // TODO random location option
        let required = ["roomName", "health", "actions"];
        for (let req of required) {
          if (!this.hasOwnProperty(req)) {
              throw new Error("No value for " + req + ": "
                  + JSON.stringify(actor));
          }
        }

        if (!this.hp) {
          this.hp = this.health;
        }

        if (!this.items) {
          this.items = [];
        }
      }

      getActionMap(){ // make map of actions to source
        let tempOut = {};

        for (let action of this.actions) {
          tempOut[action] = this;
        }
        if (this.items[0]) {
          for (let action of this.items[0].actions) {
            tempOut[action] = this.items[0]; // TODO collision
          }
        }
        return tempOut;
      }

      isAlive() {
        return this.hp > 0;
      }
    }

    class Room extends TypedClass {
      constructor(json, defs, id) {
        super(json, defs, id)
        this.category = Category.ROOMS;
        // declare default variables
        if (!this.doors) {this.doors = [];}
        if (!this.special) {this.special = [];}
        if (!this.items) {this.items=[];}
      }

      getLinks(){
          var out = [];
          for (let door of this.doors) {
              out.push(door.other(this.id));
          }
          return out;

          //TODO dspecial and addDoora
      }};

    class Door extends TypedClass {
        constructor(json, typeDefs, id) {
            super(json, typeDefs, "door" + id);
            this.category = Category.DOORS;
            if (this.rooms.length != 2) {
                throw new Error("door with " + this.rooms.length + " rooms");
            }
        }

        other(roomName) { // TODO declare elsewwhere
            if (this.rooms[0] === roomName) {
                return this.rooms[1];
            }
            if (this.rooms[1] === roomName) {
                return this.rooms[0];
            }
           throw new Error("room <" + roomName + "> not in doors");
        }
    }

    class Item extends TypedClass {
      constructor(json, typedefs, id) {
        super(json, typedefs, "item" + id);
        this.category = Category.ITEMS;
        if (!this.actions) {
          this.actions = [];
        }

        if (this.damage) {
          this.actions.push(Actions.ATTACK);
        }

        if (this.hasOwnProperty("captive")) {
          this.actions.push(Actions.CAPTURE);
        }

      }

      isUsable() {
        // weapons dpon't count
        return this.actions.length > 0;
      }
    }



  </script>
