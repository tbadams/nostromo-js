<html>
  <head>
      <link rel="stylesheet" href="styles.css">
      <title>null</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
      <p id="time">Time:0</p>

      <div  class="main" style="overflow:auto;">&nbsp;
        <div id="events">&nbsp;</div>
      </div>
      <div class="menu" >menu<br/>
        move:
        <div id="move-actions">
        </div>
        Get:
        <div id="get-actions"></div>
        Combat:
        <div id="combat-actions"></div>
        Other:
        <div id="other-actions"></div>
      </div>
              <div id="characters" class="characters"></div>
      <div class="status">
        status&nbsp;
      </div>
  </body>
</html>

<script src="buckets.js"></script>
<script>
"use strict"

/*
TODO:
  combat
  learn css
  fix room names / IDs
  split htm and js
  get rid of event log space
  names, like characters -> pcs
  deep copy def obj... shit
  scopable event log
  upside down event log?
  map display
  finish map
  make movie accurate map
  make fan recreation accurate map
  json case insensitive?

*/

const TICK_LENGTH = 1000;
const Actions = {
  MOVE:"move",
  UNLOCK:"unlock",
  ATTACK:"attack",
  GET:"get",
  DROP:"drop",
  USE:"use"
};
const Events = {
  LOG:"log"
};
const Category = {
  DOORS:"doors",
  ITEMS:"items",
  ACTORS:"actors",
  ROOMS:"rooms",
  AI:"ai",
  SPECIAL:"special"
};
const AI_PLAYER = "player";
const DEF_DEFAULT = "default";
const DEF_TYPE = "type";
const SELECTED = "selected";
const MOVE_ACTIONS = "move-actions";
const GET_ACTIONS = "get-actions";
const COMBAT_ACTIONS = "combat-actions";
const OTHER_ACTIONS = "other-actions";


    function loadJSON(callback) {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', 'http://localhost:8080/nostromo.json', true);
        xobj.onreadystatechange = function () {
            if (xobj.readyState == 4 && xobj.status == "200") {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }


    loadJSON(function(response) {
        let errorPattern = /(\d+).*/g;
        try {
          let parsed = JSON.parse(response);
          var gameData = new GameData(parsed);
          init(gameData);
          initUi(gameData);
          setInterval(function () {
              gameLoop(gameData);
          }, TICK_LENGTH);
        } catch (e) {
          if (e instanceof SyntaxError) {
            const grabRadius = 20;
              let message = e.message;
              let matched =  errorPattern.exec(message);
              let pos = matched[1]; // 1st capture
              if (pos) {
                let min = Math.max(0, pos - grabRadius);
                let max = Math.min(response.length - 1, pos + grabRadius);
                let snippet = response.substring(min, max);
                alert( 'Error loading game data JSON: ' + e + '\n\n' + snippet);
              }
          } else {
            alert('Error: ' + e);
          }
        }
    });

    function init(gameData) {
      let roomDoorMap = {};
      for (let key in Category ) {
        let category = Category[key];
        let defs = gameData.defs[category];
        let itemDefs = gameData.defs[Category.ITEMS];
        let objects = gameData[category];
        let lookup = {};
        gameData.transient.byId[category] = lookup;

        for (let i in objects) { // Instantiation pass
          objects[i] = TypedClass.create(category, objects[i], defs, i);
          if (lookup[objects[i].id]) {
            throw Error("Dupe id " + objects[i].id);
          }
          lookup[objects[i].id] = objects[i];
          // category specifc
          if (category === Category.DOORS) {
            // Get doors for each room
            let door = objects[i];
            for (let roomName of door.rooms) {
                if (!roomDoorMap.hasOwnProperty(roomName)) {
                    roomDoorMap[roomName] = {
                      id:roomName,
                        doors:[]
                    };
                }
                roomDoorMap[roomName].doors.push(door);
            }
          } else if (category === Category.ROOMS) {
            let room = objects[i];
            let roomItems = room.items;
            for (let j in roomItems) {
              roomItems[j] = TypedClass.create(Category.ITEMS, roomItems[j], itemDefs, j);
            }
          } else if (category === Category.ACTORS) {

          }
        }
      }

      // 2nd passes
      for (let key in roomDoorMap) {
        let doorList = roomDoorMap[key];
        let room = gameData.transient.byId.rooms[key];
        if (!room) {
          // Room mentioned in doors but not defined, create it
          let newRoom = new Room(doorList, gameData.defs[Category.ROOMS]);
          gameData.rooms.push(newRoom);
          gameData.transient.byId.rooms[newRoom.id] = newRoom;
        }
        // Update door list
        gameData.transient.byId.rooms[doorList.id].doors = doorList.doors;
      }

        // TODO check graph connected

        var actors = gameData.actors;
        for (let i in actors) {
          let actor = actors[i];
          if (!gameData.getByCategoryId(Category.ROOMS, actor.roomName)){
             throw new Error("actor location <" + actor.roomName + "> does not exist");
           }
        }

        if (!gameData.scheduler) {
          gameData.scheduler = buckets.PriorityQueue(function(a, b){
              // TODO unit test
              return b.time - a.time;
          });
        } else {
          // todo
          throw new Error("Scheduler persistence not implemented");
        }

    }

    function gameLoop(gameData) {
        document.getElementById("time").innerHTML = ("Time:" + gameData.time);
        var eventBus = []
        var scheduler = gameData.scheduler;

        // TODO copy gamedata
        // Handle scheduled events
        while (!scheduler.isEmpty() && scheduler.peek().time <= gameData.time) {
            eventBus.push(scheduler.dequeue());
        }
        for (let event of eventBus) {
            Action.handleAction(event, gameData);
        }

       // Queue new actions
        for (let actor of gameData.actors) {
            if (!gameData.isBusy(actor.id)) {
                var choices = Action.getChoices(actor, gameData);
                // AI actions
                if (actor.ai != AI_PLAYER) {

                    // TODO Specific AIs

                    Action.takeAction(actor, choices[Math.floor(Math.random() * choices.length)], gameData); // TODO Types

                } else {
                     // TODO handle input
                }
            }
        }

        // cull newly invalid actions
        let contents = scheduler.toArray();
        contents = contents.filter((action)=>action.isValid(gameData));
        scheduler.clear();
        for(let action of contents) {
          scheduler.add(action);
        }
        // TODO cleanup, maintenance (?)
       gameData.time = gameData.time + 1;

       draw(gameData);
    }

    function initUi(gameData) {
      // Cache view
      var view = {};
      gameData.transient.view = view;
      view.pcTabs = {};

      // character tabs
      var charTabs = document.getElementById("characters");
      for (let pc of gameData.getPcs()) {
        var newButton = document.createElement("BUTTON");
        newButton.innerHTML = pc.id;
        newButton.onclick=function(){
          selectPc(pc.id, gameData);
          draw(gameData);
        };
        charTabs.appendChild(newButton);
        view.pcTabs[pc.id] = newButton;
      }

      view.menu = {};
      view.menu.moves = document.getElementById(MOVE_ACTIONS);
      view.menu.gets = document.getElementById(GET_ACTIONS);
      view.menu.combat = document.getElementById(COMBAT_ACTIONS);
      view.menu.other = document.getElementById(OTHER_ACTIONS);

      // Validate
      for (let subview in view) {
        if (view[subview] === undefined || view[subview] === null) {
          throw Error("Empty view handle " + subview);
        }
      }
    }

    function selectPc(pcId, gameData) {
      gameData.selected = pcId;
    }

    function draw(gameData) {
      var view = gameData.transient.view;
      // PC tabs
      for (let pcId in view.pcTabs) {
        var tab = view.pcTabs[pcId];
        if (gameData.selected === pcId) {
          tab.style.color = "green";
        } else {
          tab.style.color = "black";
        }
      }

      // menu
      if(gameData.pcSelected()) {
        var pc = gameData.getByCategoryId(Category.ACTORS, gameData.selected);
        var choices = Action.getChoices(pc, gameData);
        // Move actions
        let menu = view.menu;
        for(let subview in menu) {
          emptyElem(menu[subview]);
        }
        if (!gameData.isBusy(pc.id)) {
          for(let action of choices) {
            var newButton = document.createElement("BUTTON");
            newButton.innerHTML = action.getMenuText();
            newButton.onclick=function(){
              Action.takeAction(pc, action, gameData)
              draw(gameData);
            };
            switch(action.type) {
              case Actions.MOVE:
                view.menu.moves.appendChild(newButton);
                break;
              case Actions.GET:
                view.menu.gets.appendChild(newButton);
                break;
              case Actions.ATTACK:
                view.menu.combat.appendChild(newButton);
                break;
              default:
                view.menu.other.appendChild(newButton);
                break;
            }

          }
        } // else busy

      }

    }

    function emptyElem(elem) {
      while(elem.hasChildNodes()) {
        elem.removeChild(elem.lastChild);
      }
    }

    class GameData {
      constructor(json) {
        Object.assign(this, json);
        this.transient = {};
        this.transient.byId = {};
      }

      getDefs(defType) {
        if(this.defs.hasOwnProperty(defType)) {
            return this.defs[defType];
        }
        throw Error("No defs type '" + defType + "'.")
      }

      getCategoryMap(category) {
        return this.transient.byId[category];
      }

      getByCategoryId(category, id) {
        return this.transient.byId[category][id];
      }

      getPcs() {
        return this.actors.filter(actor => actor.ai === AI_PLAYER);
      }

      pcSelected() {
        return this.hasOwnProperty(SELECTED) && this.selected != undefined
            && this.selected != null;
      }

      isBusy(actorId) {
        var busyActors = this.scheduler.toArray().map((a)=>a.actor.id); // TODO non-actors
        return busyActors.includes(actorId);
      }
    }

    class Action {
        constructor(type, target, actor) {
          if (!type || !target || !actor)
         {
           throw new Error("No null params allowed for Action");
         }
            this.type = type;
            this.target = target;
            this.actor = actor;
        }

        static byType(actions) {
          var aggregate = {};
          for (let next of actions){
            if (!next.hasOwnProperty(DEF_TYPE)) {
              throw Error("Typeless action in byType()");
            }
            if(!aggregate.hasOwnProperty(next.type)) {
              aggregate[next.type] = [];
            }
            aggregate[next.type].push(next);
          }
          return aggregate;
        }

        static getChoices(actor, gameData) {
            let out = [];
            let room = gameData.getByCategoryId(Category.ROOMS, actor.roomName);
            let addIfSupported = (action)=>{
              if (action.actor.actions.includes(action.type)
                  && action.isValid(gameData)) {
                out.push(action);
              }
            }
            if(room.items && actor.items.length < actor.inventory) {
              let items = room.items;
              for (let item of items) {
                addIfSupported(new Action(Actions.GET, item, actor));
              }
            }
            for (let door of room.doors) {
                if (!door.locked) {
                  addIfSupported(new Action(Actions.MOVE, door.other(room.id), actor));
                } else {
                  // TODO If actor supported
                  addIfSupported(new Action(Actions.UNLOCK, door, actor));
                }
            }
            // Combat
            let actorsHere = [];
            for (let otherActor of gameData.actors ) {
              if (otherActor.roomName === actor.roomName
                  && otherActor.id != actor.id) {
                    // TODO Cat-catching
                  addIfSupported(new Action(Actions.ATTACK, otherActor, actor));
              }
            }

            // Items
            if (actor.items) {
              let items = actor.items;
              for (let item of items) {
              addIfSupported(new Action(Actions.USE, item, actor));
              addIfSupported(new Action(Actions.DROP, item, actor));
              }
            }


            return out;
        }

        static handleAction(event, gameData) {
          // TODO split initiating action into multiple effects
            if (!event.isValid(gameData)) {return;}
            let actor = event.actor;
            let actorRoom = gameData
                .getByCategoryId(Category.ROOMS, event.actor.roomName);
            let target = event.target;
            if (event.type === Actions.MOVE) {
                event.actor.roomName = event.target;
            } else if (event.type === Actions.UNLOCK) {
                event.target.locked = false;
            } else if (event.type === Actions.ATTACK) {
                let weapon = actor.getWeapon();
                if (weapon) {
                  target.health -= weapon.damage;
                  if(!weapon.nobleed) {
                    // TODO bleed
                  }
                }
            } else if (event.type === Actions.GET) {
              let item = event.target;
              actorRoom.items = actorRoom.items.filter((thing)=>thing != item);
                event.actor.items.push(event.target);
            } else if (event.type === Actions.DROP) {
              // Move item to room
              let item = event.target;
              // TODO this
              event.actor.items = event.actor.items.filter((thing)=>thing != item);
              actorRoom.items.push(item);
            } else if (event.type === Actions.USE) {
              // TODO ...use it
            }
            var log = document.getElementById("events");
            log.innerHTML= log.innerHTML + (event.getEventText(gameData) + "<br/>");
        }

        static takeAction(actor, action, gameData) { // todo rename queue
            if (action.isValid(gameData)) {
              var length = Action.duration(action, gameData);
              action.time = gameData.time + length;
              gameData.scheduler.enqueue(action);
            } else {
              gameData.scheduler.enqueue(new Action(Events.LOG, "invalid action taken", 0));
            }
        }

        static duration(action, gameData) {
          return 3;
        }

        isValid(gameData) {
          if (!gameData) {throw new Error("NO MORE NULL GAMEDATA");}
          let actor = this.actor;
          let target = this.target;
          let actorRoom = gameData
              .getByCategoryId(Category.ROOMS, actor.roomName);
          switch(this.type) {
            case Actions.MOVE: // target=roomName
              return actorRoom.getLinks().includes(target);
            case Actions.UNLOCK: // target=door object
              return target.rooms.includes(actor.roomName);
            case Actions.ATTACK: // actor object
              return actor.roomName === target.roomName
                  && actor.getWeapon();
            case Actions.GET: // room item
              return actorRoom.items.includes(target)
                && actor.items.length < actor.inventory;
            case Actions.DROP: // actor item
              return actor.items.includes(target);
            case Actions.USE:
              actorRoom.items.includes(target) || actor.items.includes(target);
            case Events.LOG:
              return true;
            default:
              throw new Error("Unsupported action validation: " + this.type);
          }
        }

        getMenuText() {
          // TODO make consistent?
          switch(this.type) {
            case Actions.MOVE:
              return this.target;
            case Actions.UNLOCK:
              return "Unlock Grate"; // TODO localize?
            case Actions.ATTACK:
              return "Attack " + this.target.id;
            case Actions.GET:
              return this.target.type;
            case Actions.DROP:
              return "Drop " + this.target.type;
            case Actions.USE:
              return "Use " + this.target.type;
            default:
              throw new Error("Unsupported action text: " + this.type);
          }
        }

        getEventText(gameData) {
            let type = this.type;
            switch(type) {
              case Actions.MOVE:
                return this.actor.id + " moved to " + this.target + ".";
              case Actions.UNLOCK:
                return this.actor.id + " unlocked " + this.target.id + ".";
              case Actions.ATTACK:
                // TODO passive voice?
                return this.actor.id + " attacked " + this.target.id + ".";
              case Actions.GET:
                return this.actor.id + " picked up " + this.target.type + ".";
              case Actions.DROP:
                return this.actor.id + " dropped " + this.target.type + ".";
              case Actions.USE:
                return this.actor.id + " used " + this.target.type + ".";
              case Events.LOG:
                // TODO debug flag
                return "Log: " + target;
            }

            return "UNHANDLED EVENT:" + JSON.stringify(event);
        }
    }

    class TypedClass {

        constructor(json, typeDefs, id) {
            // Assign characteristics hierarchically
            this.id = id; // Prefer id from data
            if (typeDefs.hasOwnProperty(DEF_DEFAULT)) {  // Type default
                Object.assign(this, typeDefs[DEF_DEFAULT]);
            }
            if (json.hasOwnProperty(DEF_TYPE)) { // Specific type
                var jsonType = json[DEF_TYPE];
                if (typeDefs.hasOwnProperty(jsonType)) {
                    Object.assign(this, typeDefs[jsonType]);
                } else {
                    throw Error("No defined type: " + jsonType);
                }
            }
            Object.assign(this, json); // Specific instance

            // Validate common properties
            if (!this.id) {
              throw Error("Typed object has no id");
            }
        }

        static create(category, json, def, id) {
          switch(category) {
            case Category.ACTORS:
              return new Actor(json, def, id);
            case Category.DOORS:
              return new Door(json, def, id);
            case Category.ITEMS:
              return new Item(json, def, id);
            case Category.ROOMS:
              return new Room(json, def, id);
            default:
              throw new Error("Unsupported category " + category);
          }
        }
    }

    class Actor extends TypedClass {
      constructor(json, defs) {
        super(json, defs);
        this.category = Category.ACTORS;

        // TODO default or require: inventory, attack
        // TODO random location option
        if (!this.hasOwnProperty("roomName")) {
            throw new Error("No location:" + JSON.stringify(actor));
        }
        // Assign default allowed actions (all)
        if (!this.actions) {
          this.actions = [];
          for (let type in Actions) {
            this.actions.push(Actions[type]);
          }
        }

        if (!this.items) {
          this.items = [];
        }
      }

      getWeapon() {
        if (this.items.length > 0 && this.items[0].weapon) {
          // has weapon equipped
          return this.items[0].weapon;
        }
        return this.weapon;
      }

      isAlive() {
        return health > 0;
      }
    }

    class Room extends TypedClass {
      constructor(json, defs, id) {
        super(json, defs, id)
        this.category = Category.ROOMS;
        // declare default variables
        if (!this.doors) {this.doors = [];}
        if (!this.special) {this.special = [];}
        if (!this.items) {this.items=[];}
      }

      getLinks(){
          var out = [];
          for (let door of this.doors) {
              out.push(door.other(this.id));
          }
          return out;

          //TODO dspecial and addDoora
      }};

    class Door extends TypedClass {
        constructor(json, typeDefs, id) {
            super(json, typeDefs, "door" + id);
            this.category = Category.DOORS;
            if (this.rooms.length != 2) {
                throw new Error("door with " + this.rooms.length + " rooms");
            }
        }

        other(roomName) { // TODO declare elsewwhere
            if (this.rooms[0] === roomName) {
                return this.rooms[1];
            }
            if (this.rooms[1] === roomName) {
                return this.rooms[0];
            }
           throw new Error("room <" + roomName + "> not in doors");
        }

        toString() {
            return "Door[" + this.rooms[0] + "/" + this.rooms[1] + "]";
        }
    }

    class Item extends TypedClass {
      constructor(json, typedefs, id) {
        super(json, typedefs, "item" + id);
        this.category = Category.ITEMS;
      }
    }



  </script>
