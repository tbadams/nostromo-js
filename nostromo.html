<html>
  <head>
      <link rel="stylesheet" href="styles.css">
      <title>null</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <p id="topBar">
      <span id="time">&nbsp;</span>
      <span id="oxygen"></span>
      <span id="destruct"></span>
    </p>

      <div  class="main" style="overflow:auto;">&nbsp;
        <div id="events">&nbsp;</div>
      </div>
      <div class="menu" >menu<br/>
        move:
        <div id="move-actions">
        </div>
        Get:
        <div id="get-actions"></div>
        Combat:
        <div id="combat-actions"></div>
        Other:
        <div id="other-actions"></div>
      </div>
              <div id="characters"></div>
      <div class="status">
        status&nbsp;
        <div id="room-line">
          <span id="room-name"></span>
          <span id="room-health"></span>
        </div>
        <div id="pc-status"></div>
        <div id="room-description"></div>
      </div>
  </body>
</html>

<script src="buckets.js"></script>
<script src="dataTests.js"></script>
<script src="server.js"></script>
<script src="util.js"></script>
<script src="data.js"></script>
<script>
"use strict"

/*
TODO:
actions have speed
counter start should delay 1 tick (to show 5:00 on bomb timer)
isalive refactor
SEPERATE GODDAMN FILES
move category into TypedClass
refine selectors
  miss chance
  wound logs (and miss) as seprate event
  show pending action
  acid blood
  all interobject refs through IDs, no references
  replace void room with item/actor/etc. "rooms"
    generic item action code
  ai system
  widgets and service
  split htm and js
  get rid of event log space
  names, like characters -> pcs
  deep copy def obj (?)
  scopable event log
  add 'config' object, mostly for debugging
    disable clicking on dead pc tab
  upside down event log?
  generate js signature docs
  map display
  finish map
  make movie accurate map
  make fan recreation accurate map
  json case insensitive?
  pending action progress bar
fix stupid json error catching code
localization??
*/

const TICK_LENGTH = 1000;
const Health = {
  OK:"OK",
  WOUNDED:"wounded",
  DEAD:"dead"
};
const AI_PLAYER = "player";
const DEF_DEFAULT = "default";
const DEF_TYPE = "type";
const SELECTED = "selected";
const MOVE_ACTIONS = "move-actions";
const GET_ACTIONS = "get-actions";
const COMBAT_ACTIONS = "combat-actions";
const OTHER_ACTIONS = "other-actions";
const VOID = "void"; // Room for when need "nowhere"
const CATEGORY_ALL = "all";
const OXYGEN = "oxygen";
const DESTRUCT = "destruct";

    loadJSON(function(response) {
        let errorPattern = /(\d+).*/g;
        var parsed;
        try {
          parsed = JSON.parse(response);
        } catch (e) {
          if (e instanceof SyntaxError) {
            const grabRadius = 20;
              let message = e.message;
              let matched =  errorPattern.exec(message);
              let pos = matched[1]; // 1st capture
              if (pos) {
                let min = Math.max(0, pos - grabRadius);
                let max = Math.min(response.length - 1, pos + grabRadius);
                let snippet = response.substring(min, pos)
                    + ">HERE<" + response.substring(pos, max);
                alert( 'Error loading game data JSON: ' + e + '\n\n' + snippet);
              }
          } else {
            alert('Error: ' + e);
          }
          return;
        }
        var gameData = new GameData(parsed);
        preInitTests(gameData);
        init(gameData);
        initUi(gameData);
        setInterval(function () {
            gameLoop(gameData);
        }, TICK_LENGTH);
    });

    function preInitTests (gameData) {
      let testResults = testAll();
      let failed = testResults.filter(result=>!result.passed);

      if (failed.length > 0) {
        let report = "" + failed.length + " of " + testResults.length
            + " tests failed:\n";
        for (let result of failed) {
          report += result.name + ":\n" + result.error.message + "\n\n";
        }
        alert(report);
      }
    }

    function init(gameData) {
      if (!gameData.state) {
        // Extra initialization for first ever run
        gameData.state = {
          time:0,
          paused:false
        }
        // Generate implied rooms from doors
        // Get the list of door ids for every room
        let roomDoorMap = {};
        gameData.rooms.push({id: VOID, doorIds:[]}); // VOID room, for taking things out of level
        for (let i in gameData.doors) {
          gameData.doors[i] = new Door(gameData.doors[i], gameData.defs.doors, i);
          let door = gameData.doors[i];
          for (let roomName of door.rooms) {
              if (!roomDoorMap.hasOwnProperty(roomName)) {
                  roomDoorMap[roomName] = {
                    id:roomName,
                      doorIds:[]
                  };
              }
              roomDoorMap[roomName].doorIds.push(door.id);
          }
        }
        // Assign door id lists to rooms that already exist
        for (let room of gameData.rooms) {
          if (roomDoorMap[room.id] && roomDoorMap[room.id].doorIds) {
            room.doorIds = roomDoorMap[room.id].doorIds;
            delete roomDoorMap[room.id];
          }
        }
        // Create remaining ("implied") ROOMS
        for (let roomName in roomDoorMap) {
          gameData.rooms.push(roomDoorMap[roomName]);
        }

        // Grab objects nested in others, extract to top level
        for (let category of asList(Category)) {
          let objects = gameData[category];
          for (let object of objects) {
            for (let category2 of asList(Category)){
              if (!gameData[category2]) {
                gameData[category2] = [];
              }
              if (object[category2] && category2 != Category.ROOMS) { // nothing can contain rooms... yet
                if (!object.id) {throw Error("no id");}
                for ( let contained of object[category2]) {
                  contained.roomName = object.id; // TODO Generify
                  gameData[category2].push(contained);
                }
                delete object[category2];
              }
            }
          }
        }
      }

      // Actual game initialization
      let lookupAll = {}
      gameData.transient.byId.all = lookupAll;

      for (let key in Category ) {
        let category = Category[key];
        let defs = gameData.defs[category];
        let itemDefs = gameData.defs[Category.ITEMS];
        let objects = gameData[category];
        let lookup = {};
        gameData.transient.byId[category] = lookup;

        for (let i in objects) { // Instantiation pass
          objects[i] = TypedClass.create(category, objects[i], defs, i);
          let object = objects[i];
          if (lookup[object.id] || lookupAll[object.id]) {
            throw Error("Dupe id " + object.id);
          }
          lookup[object.id] = object;
          lookupAll[object.id] = object;
        }
      }

        // TODO check graph connected

        // validate each contained has valid container, set up mem references
        let all = gameData.transient.byId.all;
        for (let i in all) {
          let thing = all[i]
          if (thing.roomName) { // TODO generify
            if (!gameData.getByCategoryId(Category.ROOMS, thing.roomName)){
               throw new Error("thing location <" + thing.roomName + "> does not exist");
             } else {
                // inform parent
                let parent = all[thing.roomName];
                let cat = thing.category;
                if (!parent.transient[cat]) {
                  parent.transient[cat] = [];
                }
                parent.transient[cat].push(thing);
             }
           }
        }

        if (!gameData.scheduler) {
          gameData.scheduler = buckets.PriorityQueue(function(a, b){
              // TODO unit test
              return b.time - a.time;
          });
        } else {
          // TODO
          throw new Error("Scheduler persistence not implemented");
        }
    }

    function gameLoop(gameData) {
        var eventBus = []
        var scheduler = gameData.scheduler;

        // TODO copy gamedata
        // Handle scheduled events
        while (!scheduler.isEmpty() && scheduler.peek().time <= gameData.state.time) {
            eventBus.push(scheduler.dequeue());
        }
        // check validity *before* resolving any Actions
        eventBus = eventBus.filter(event=>event.isValid(gameData));
        for (let event of eventBus) {
            Action.handleAction(event, gameData);
        }

       // Queue new actions
        for (let actor of gameData.getAll()) {
          // not preoccupied doing something, like being dead or in a box
            if (actor.takesActions() && !gameData.isBusy(actor.id)) {
                var choices = Action.getChoices(actor, gameData);
                // AI actionsgameData.getAll()
                if (actor.ai != AI_PLAYER) {
                    // TODO Specific AIs
                    if (choices.length > 0) {
                      Action.takeAction(actor, choices[Math.floor(Math.random() * choices.length)], gameData); // TODO Types
                    }
                } else {
                     // TODO handle input
                }
            }
        }

        // cull newly invalid actions
        let contents = scheduler.toArray();
        contents = contents.filter((action)=>action.isValid(gameData));
        scheduler.clear();
        for(let action of contents) {
          scheduler.add(action);
        }
        // TODO cleanup, maintenance (?)
       gameData.state.time = gameData.state.time + 1;

       draw(gameData);
    }

    function initUi(gameData) {
      // Cache view
      var view = {};
      gameData.transient.view = view;
      view.pcTabs = {};

      // character tabs
      var charTabs = document.getElementById("characters");
      for (let pc of gameData.getPcs()) {
        var newButton = document.createElement("BUTTON");
        newButton.innerHTML = pc.id;
        newButton.onclick=function(){
          selectPc(pc.id, gameData);
          draw(gameData);
        };
        charTabs.appendChild(newButton);
        view.pcTabs[pc.id] = newButton;
      }

      view.menu = {};
      view.menu.moves = document.getElementById(MOVE_ACTIONS);
      view.menu.gets = document.getElementById(GET_ACTIONS);
      view.menu.combat = document.getElementById(COMBAT_ACTIONS);
      view.menu.other = document.getElementById(OTHER_ACTIONS);

      view.status = {}
      view.status.roomName = document.getElementById("room-name");
      view.status.roomHealth = document.getElementById("room-health");
      view.status.pcStatus = document.getElementById("pc-status");
      view.status.roomDescription = document.getElementById("room-description");

      // Validate
      validateView(view);
    }

    function validateView(view) {
      for (let key in view) {
        let subview = view[key];
        if (!subview) {
          throw Error("Empty view handle " + subview);
        }
        for (let subkey in subview) {
          let subsubview = subview[subkey];
          if (!subsubview) {
            throw Error("Empty subview handle " + subview);
          }
        }
      }
    }

    function selectPc(pcId, gameData) {
      let pc = gameData.getByCategoryId(Category.ACTORS, pcId);
      if (pc.ai === AI_PLAYER && pc.isAlive()) {
        gameData.selected = pcId; // TODO rename selectedId
      } else {
        gameData.selected = null;
      }
    }

    function draw(gameData) {
      var view = gameData.transient.view;

      // Top bar
      document.getElementById("time").innerHTML = ("Time:" + gameData.state.time);
      let oxygen = gameData.getByCategoryId(CATEGORY_ALL, OXYGEN);
      if (oxygen) {
        let displayCount = Math.max(0, oxygen.count);
        document.getElementById(OXYGEN).innerHTML = ("Oxygen:" + displayCount);
      }
      let destruct = gameData.getByCategoryId(CATEGORY_ALL, DESTRUCT);
      if (destruct && destruct.activated) { // show only when counting down
        // TODO account for tics vs seconds
        document.getElementById(DESTRUCT).innerHTML =
        "Self Destruct: " + timeFormat(destruct.count);
      } else {
        document.getElementById(DESTRUCT).innerHTML = "";
      }

      // PC tabs
      for (let pcId in view.pcTabs) {
        var tab = view.pcTabs[pcId];
        if (gameData.selected === pcId) {
          tab.style.color = "green";
        } else {
          tab.style.color = "black";
        }

        if (!gameData.getByCategoryId(Category.ACTORS, pcId).isAlive()) {
          tab.style.color = "black";
          tab.style.opacity = 0.6;
        }
      }

      // menu & status
      let menu = view.menu;
      for(let subview in menu) {
        emptyElem(menu[subview]);
      }
      let status = view.status;
      for (let key in status) {
        emptyElem(status[key]);
      }
      if(gameData.pcSelected()) {
        var pc = gameData.getByCategoryId(Category.ACTORS, gameData.selected);
        var choices = Action.getChoices(pc, gameData);
        // Move actions

        if (pc.isAlive() && !gameData.isBusy(pc.id)) {
          for(let action of choices) {
            var newButton = document.createElement("BUTTON");
            newButton.innerHTML = action.getMenuText();
            newButton.onclick=function(){
              Action.takeAction(pc, action, gameData)
              draw(gameData);
            };
            switch(action.type) {
              case Actions.MOVE:
                view.menu.moves.appendChild(newButton);
                break;
              case Actions.GET:
                view.menu.gets.appendChild(newButton);
                break;
              case Actions.ATTACK:
                view.menu.combat.appendChild(newButton);
                break;
              default:
                view.menu.other.appendChild(newButton);
                break;
            }

          }
        } // else busy

        // status
        let room = gameData.getByCategoryId(Category.ROOMS, pc.roomName);
        view.status.roomName.innerHTML = room.id;
        view.status.roomHealth.innerHTML = room.health + "%";
        let healthText;
        if (pc.hp > pc.health / 2) {
          healthText = "OK";
        } else if (pc.hp > 0) {
          healthText = "wounded";
        } else if (!pc.isAlive()) {
          healthText = "dead";
        } else {
          healthText = "drunk"; // this is a joke
        }
        view.status.pcStatus.innerHTML = pc.id + " is " + healthText
            + " and stable."
      }
    }

    function timeFormat(seconds) {
      if (seconds < 0) {return "0:00";}
      let min = Math.floor(seconds / 60);
      let remainder = seconds % 60;
      let secondsZero = remainder < 10 ? "0" : "";
      return min + ":" + secondsZero + remainder;
    }

    function emptyElem(elem) {
      while(elem.hasChildNodes()) {
        elem.removeChild(elem.lastChild);
      }
    }
  </script>
