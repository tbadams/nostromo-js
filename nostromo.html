<script src="buckets.js"></script>
<script>
"use strict"

const TICK_LENGTH = 1000;
const ACTION_MOVE = "move";
const AI_PLAYER = "player";

    function loadJSON(callback) {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', 'http://localhost:8080/nostromo.json', true);
        xobj.onreadystatechange = function () {
            if (xobj.readyState == 4 && xobj.status == "200") {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }
 

    loadJSON(function(response) {
        var gameData = JSON.parse(response);
        init(gameData);
        setInterval(function () {
            gameLoop(gameData);
        }, TICK_LENGTH)
    });

    function init(gameData) {
        validateDoors(gameData.doors);
        for(let door of gameData.doors) {
            door.other = function(roomName) {
                if (this.rooms[0] === roomName) {
                    return this.rooms[1];
                }
                if (this.rooms[1] === roomName) {
                    return this.rooms[0];
                }
               throw new Error("room <" + roomName + "> not in doors");
            }
            for (let roomName of door.rooms) {
                if (!gameData.rooms.hasOwnProperty(roomName)) {
                    gameData.rooms[roomName] = {
                        name:roomName,
                        doors:[],
                        links(){
                            var out = [];
                            for (let door of this.doors) {
                                out.push(door.other(this.name));
                            }
                            return out;
                        }};
                }
                gameData.rooms[roomName].doors.push(door);
            }
        }
        // TODO check graph connected
        // document.write("data:" + JSON.stringify(gameData));

        var actors = gameData.actors;
        var ai = [];
        var players = [];
        for (let actor of actors) {
            if (actor.ai === "player") {
                players.push(actor);
            } else {
                // TODO Validate
                ai.push(actor);

            }
            // TODO default or require: inventory, attack
            // TODO random location option
            if (!actor.hasOwnProperty("roomName")) { // TODO call roomName for clarity
                throw new Error("No location:" + JSON.stringify(actor));
            } else if (!gameData.rooms.hasOwnProperty(actor.roomName) ){
                throw new Error("actor location <" + actor.roomName + "> does not exist");
            }
            // TODO check name is unique
        }

        var items = [];

        var scheduler = buckets.PriorityQueue(function(a, b){
            // TODO unit test
            return b.time - a.time;
        });
        gameData.scheduler = scheduler;

    }

    function gameLoop(gameData) {
        
        document.write("\ntime:" + gameData.time);
        var eventBus = []
        var scheduler = gameData.scheduler;

        // TODO copy gamedata

        while (!scheduler.isEmpty() && scheduler.peek().time <= gameData.time) {
            eventBus.push(scheduler.dequeue());
        }
        for (let event of eventBus) {
            if (event.type === ACTION_MOVE) {
                // TODO move
                event.actor.roomName = event.target
            }
            document.writeln("<p>" + eventText(event, gameData) + "</p>");
        }

       
        var busyActors = scheduler.toArray().map((a)=>a.actor.name); // TODO non-actors
        for (let actor of gameData.actors) {
            if (!busyActors.includes(actor.name)) {
                // AI actions
                if (actor.ai != AI_PLAYER) {
                    var choices = getActions(actor, gameData);
                    // TODO Specific AIs

                    takeAction(actor, choices[Math.floor(Math.random() * choices.length)], gameData); // TODO Types

                } else {
                     // TODO handle input
                }
            }
        }

        // TODO cleanup, maintenance (?)
       gameData.time = gameData.time + 1;

    }

    function takeAction(actor, action, gameData) {
        var length = 5; // TODO ??
        action.time = gameData.time + length;
        gameData.scheduler.enqueue(action);
    }

    function validateDoors(doors) {
        for (let door of doors) {
            if (door.rooms.length != 2) {
                throw new Error("door with " + rooms.length + " rooms");
            }
        }
    }

    function eventText(event, gameData) {
        var type = event.type;
        if (type === ACTION_MOVE) {
            return event.actor.name + " moved to " + event.target + ".";
        }
        return "UNHANDLED EVENT:" + JSON.stringify(event);
    }

    function getActions(actor, gameData) {
        var out = [];
        var room = gameData.rooms[actor.roomName];
        for (let connection of room.links()) {
            out.push(new Action(ACTION_MOVE, connection, actor));
        }
        return out;
    }

    class Action {
        constructor(type, target, actor) {
            this.type = type;
            this.target = target;
            this.actor = actor;
        }
    }


    //alert( 'Hello, world!' + makeData(23, 15, 10, 0.5));
  </script>

  <html>
    <head>
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <p name="time"></p>
    </body>
  </html>