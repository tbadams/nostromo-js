<html>
  <head>
      <link rel="stylesheet" href="styles.css">
      <title>null</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <div id="mainScreen" class="screen">
    <p id="topBar">
      <span id="time">&nbsp;</span>
      <span id="oxygen"></span>
      <span id="destruct"></span>
    </p>

      <div  class="main" style="overflow:auto;">&nbsp;
        <div id="events">&nbsp;</div>
      </div>
      <div class="menu" >MENU<br/><br/>
        <div id="move-actions-header">MOVE</div>
        <div id="move-actions">
        </div>
        <div id="get-actions-header">GET</div>
        <div id="get-actions"></div>
        <div id="combat-actions-header">COMBAT</div>
        <div id="combat-actions"></div>
        <div id="other-actions-header">OTHER</div>
        <div id="other-actions"></div>
      </div>
              <div id="characters"></div>
      <div class="status">
        status&nbsp;
        <div id="room-line">
          <span id="room-name"></span>
          <span id="room-health"></span>
        </div>
        <div id="pc-status"></div>
        <div id="room-description"></div>
      </div>
    </div>
    <div id="endgame" class="screen">
        GARBAGE DAY
    </div>
  </body>
</html>

<script src="buckets.js"></script>
<script src="dataTests.js"></script>
<script src="server.js"></script>
<script src="util.js"></script>
<script src="data.js"></script>
<script>
"use strict"

/*
TODO:
actions have speed
counter start should delay 1 tick (to show 5:00 on bomb timer)
isalive refactor
move category into TypedClass
refine selectors
miss chance
wound logs (and miss) as seprate event
show pending action
acid blood
all interobject refs through IDs, no references (Actions remain primarily)
generic item action code
ai system
split htm and js
get rid of event log space
names, like characters -> pcs
deep copy def obj (?)
scopable event log
  different messages for diff scopes
log to console?
add 'config' object, mostly for debugging
disable clicking on dead pc tab (?)
upside down event log
generate js signature docs
map display
finish map
make movie accurate map
make fan recreation accurate map
json case insensitive?
pending action progress bar
fix stupid json error catching code
localization??
*/

const TICK_LENGTH = 1000;
const Health = {
  OK:"OK",
  WOUNDED:"wounded",
  DEAD:"dead"
};
const CLASS_SCREEN = "screen"
const Screens = {
  MAIN_SCREEN:"mainScreen",
  ENDGAME:"endgame"
};
const AI_PLAYER = "player";
const SELECTED = "selected";
const MOVE_ACTIONS = "move-actions";
const GET_ACTIONS = "get-actions";
const COMBAT_ACTIONS = "combat-actions";
const OTHER_ACTIONS = "other-actions";
const VOID = "void"; // Room for when need "nowhere"
const CATEGORY_ALL = "all";
const OXYGEN = "oxygen";
const DESTRUCT = "destruct";

    loadJSON(function(response) {
        let errorPattern = /(\d+).*/g;
        var parsed;
        try {
          parsed = JSON.parse(response);
        } catch (e) {
          if (e instanceof SyntaxError) {
            const grabRadius = 20;
              let message = e.message;
              let matched =  errorPattern.exec(message);
              let pos = matched[1]; // 1st capture
              if (pos) {
                let min = Math.max(0, pos - grabRadius);
                let max = Math.min(response.length - 1, pos + grabRadius);
                let snippet = response.substring(min, pos)
                    + ">HERE<" + response.substring(pos, max);
                alert( 'Error loading game data JSON: ' + e + '\n\n' + snippet);
              }
          } else {
            alert('Error: ' + e);
          }
          return;
        }
        var gameData = new GameData(parsed);
        preInitTests(gameData);
        init(gameData);
        initUi(gameData);
        setInterval(function () {
            gameLoop(gameData);
        }, TICK_LENGTH);
    });

    function preInitTests (gameData) {
      let testResults = testAll();
      let failed = testResults.filter(result=>!result.passed);

      if (failed.length > 0) {
        let report = "" + failed.length + " of " + testResults.length
            + " tests failed:\n";
        for (let result of failed) {
          report += result.name + ":\n" + result.error.message + "\n\n";
        }
        alert(report);
      }
    }

    function init(gameData) {
      if (!gameData.state) {
        // Extra initialization for first ever run
        gameData.state = {
          time:0,
          paused:false
        }
        // Generate implied rooms from doors
        // Get the list of door ids for every room
        let roomDoorMap = {};
        gameData.rooms.push({id: VOID, doorIds:[]}); // VOID room, for taking things out of level
        for (let i in gameData.doors) {
          gameData.doors[i] = new Door(gameData.doors[i], gameData.defs.doors, i);
          let door = gameData.doors[i];
          for (let roomName of door.rooms) {
              if (!roomDoorMap.hasOwnProperty(roomName)) {
                  roomDoorMap[roomName] = {
                    id:roomName,
                      doorIds:[]
                  };
              }
              roomDoorMap[roomName].doorIds.push(door.id);
          }
        }
        // Assign door id lists to rooms that already exist
        for (let room of gameData.rooms) {
          if (roomDoorMap[room.id] && roomDoorMap[room.id].doorIds) {
            room.doorIds = roomDoorMap[room.id].doorIds;
            delete roomDoorMap[room.id];
          }
        }
        // Create remaining ("implied") ROOMS
        for (let roomName in roomDoorMap) {
          gameData.rooms.push(roomDoorMap[roomName]);
        }

        // Grab objects nested in others, extract to top level
        for (let category of asList(Category)) {
          let objects = gameData[category];
          for (let object of objects) {
            for (let category2 of asList(Category)){
              if (!gameData[category2]) {
                gameData[category2] = [];
              }
              if (object[category2] && category2 != Category.ROOMS) { // nothing can contain rooms... yet
                if (!object.id) {throw Error("no id");}
                for ( let contained of object[category2]) {
                  contained.roomName = object.id; // TODO Generify
                  gameData[category2].push(contained);
                }
                delete object[category2];
              }
            }
          }
        }
      }

      // Actual game initialization
      let lookupAll = {}
      gameData.transient.byId.all = lookupAll;

      for (let key in Category ) {
        let category = Category[key];
        let defs = gameData.defs[category];
        let itemDefs = gameData.defs[Category.ITEMS];
        let objects = gameData[category];
        let lookup = {};
        gameData.transient.byId[category] = lookup;

        for (let i in objects) { // Instantiation pass
          objects[i] = TypedClass.create(category, objects[i], defs, i);
          let object = objects[i];
          if (lookup[object.id] || lookupAll[object.id]) {
            throw Error("Dupe id " + object.id);
          }
          lookup[object.id] = object;
          lookupAll[object.id] = object;
        }
      }

        // TODO check graph connected

        // validate each contained has valid container, set up mem references
        let all = gameData.transient.byId.all;
        for (let i in all) {
          let thing = all[i]
          if (thing.roomName) { // TODO generify
            if (!gameData.getByCategoryId(Category.ROOMS, thing.roomName)){
               throw new Error("thing location <" + thing.roomName + "> does not exist");
             } else {
                // inform parent
                let parent = all[thing.roomName];
                let cat = thing.category;
                if (!parent.transient[cat]) {
                  parent.transient[cat] = [];
                }
                parent.transient[cat].push(thing);
             }
           }
        }

        if (!gameData.scheduler) {
          gameData.scheduler = buckets.PriorityQueue(function(a, b){
              // TODO unit test
              return b.time - a.time;
          });
        } else {
          // TODO
          throw new Error("Scheduler persistence not implemented");
        }
    }

    function gameLoop(gameData) {
        var eventBus = []
        var scheduler = gameData.scheduler;

        // TODO copy gamedata
        // Handle scheduled events
        while (!scheduler.isEmpty() && scheduler.peek().time <= gameData.state.time) {
            eventBus.push(scheduler.dequeue());
        }
        // check validity *before* resolving any Actions
        eventBus = eventBus.filter(event=>event.isValid(gameData));
        for (let event of eventBus) {
            Action.handleAction(event, gameData);
        }

       // Queue new actions
        for (let actor of gameData.getAll()) {
          // not preoccupied doing something, like being dead or in a box
            if (actor.takesActions() && !gameData.isBusy(actor.id)) {
                var choices = Action.getChoices(actor, gameData);
                // AI actionsgameData.getAll()
                if (actor.ai != AI_PLAYER) {
                    // TODO Specific AIs
                    if (choices.length > 0) {
                      Action.takeAction(actor, choices[Math.floor(Math.random() * choices.length)], gameData); // TODO Types
                    }
                } else {
                     // TODO handle input
                }
            }
        }

        // cull newly invalid actions
        let contents = scheduler.toArray();
        contents = contents.filter((action)=>action.isValid(gameData));
        scheduler.clear();
        for(let action of contents) {
          scheduler.add(action);
        }
        // TODO cleanup, maintenance (?)
       gameData.state.time = gameData.state.time + 1;

       draw(gameData);
    }

    function initUi(gameData) {
      // Cache view
      var view = {};
      gameData.transient.view = view;
      view.pcTabs = {};

      // events
      var events = {events : []};
      view.events = events;

      // character tabs
      var charTabs = document.getElementById("characters");
      for (let pc of gameData.getPcs()) {
        var newButton = document.createElement("BUTTON");
        newButton.innerHTML = pc.id;
        newButton.onclick=function(){
          selectPc(pc.id, gameData);
          draw(gameData);
        };
        charTabs.appendChild(newButton);
        view.pcTabs[pc.id] = newButton;
      }

      view.menu = {};
      view.menu.moves = document.getElementById(MOVE_ACTIONS);
      view.menu.gets = document.getElementById(GET_ACTIONS);
      view.menu.combat = document.getElementById(COMBAT_ACTIONS);
      view.menu.other = document.getElementById(OTHER_ACTIONS);

      view.status = {}
      view.status.roomName = document.getElementById("room-name");
      view.status.roomHealth = document.getElementById("room-health");
      view.status.pcStatus = document.getElementById("pc-status");
      view.status.roomDescription = document.getElementById("room-description");

      // Validate
      validateView(view);

      nav(Screens.MAIN_SCREEN);
    }

    function validateView(view) {
      for (let key in view) {
        let subview = view[key];
        if (!subview) {
          throw Error("Empty view handle " + subview);
        }
        for (let subkey in subview) {
          let subsubview = subview[subkey];
          if (!subsubview) {
            throw Error("Empty subview handle " + subview);
          }
        }
      }

      // TODO validate all screens in Screens exist
    }

    function selectPc(pcId, gameData) {
      let pc = gameData.getByCategoryId(Category.ACTORS, pcId);
      if (pc.ai === AI_PLAYER && pc.isAlive()) {
        gameData.selected = pcId; // TODO rename selectedId
      } else {
        gameData.selected = null;
      }
    }

    function draw(gameData) {
      var view = gameData.transient.view;

      // Top bar
      document.getElementById("time").innerHTML = ("Time:" + gameData.state.time);
      let oxygen = gameData.getByCategoryId(CATEGORY_ALL, OXYGEN);
      if (oxygen) {
        let displayCount = Math.max(0, oxygen.count);
        document.getElementById(OXYGEN).innerHTML = ("Oxygen:" + displayCount);
      }
      let destruct = gameData.getByCategoryId(CATEGORY_ALL, DESTRUCT);
      if (destruct && destruct.activated) { // show only when counting down
        // TODO account for tics vs seconds
        document.getElementById(DESTRUCT).innerHTML =
        "Self Destruct: " + timeFormat(destruct.count);
      } else {
        document.getElementById(DESTRUCT).innerHTML = "";
      }

      // PC tabs
      for (let pcId in view.pcTabs) {
        var tab = view.pcTabs[pcId];
        if (gameData.selected === pcId) {
          tab.style.color = "green";
        } else {
          tab.style.color = "black";
        }

        if (!gameData.getByCategoryId(Category.ACTORS, pcId).isAlive()) {
          tab.style.color = "black";
          tab.style.opacity = 0.6;
        }
      }

      // menu & status
      let menu = view.menu;
      for(let subview in menu) {
        emptyElem(menu[subview]);
      }
      let status = view.status;
      for (let key in status) {
        emptyElem(status[key]);
      }
      if(gameData.pcSelected()) {
        var pc = gameData.getByCategoryId(Category.ACTORS, gameData.selected);
        var choices = Action.getChoices(pc, gameData);
        // Move actions

        if (pc.isAlive() && !gameData.isBusy(pc.id)) {
          for(let action of choices) {
            var newButton = document.createElement("BUTTON");
            newButton.innerHTML = getMenuText(action);
            newButton.onclick=function(){
              Action.takeAction(pc, action, gameData)
              draw(gameData);
            };
            switch(action.type) {
              case Actions.MOVE:
                view.menu.moves.appendChild(newButton);
                break;
              case Actions.GET:
                view.menu.gets.appendChild(newButton);
                break;
              case Actions.ATTACK:
                view.menu.combat.appendChild(newButton);
                break;
              default:
                view.menu.other.appendChild(newButton);
                break;
            }

          }
        } // else busy

        // status
        let room = gameData.getByCategoryId(Category.ROOMS, pc.roomName);
        view.status.roomName.innerHTML = room.id;
        view.status.roomHealth.innerHTML = room.health + "%";
        let healthText;
        if (pc.hp > pc.health / 2) {
          healthText = "OK";
        } else if (pc.hp > 0) {
          healthText = "wounded";
        } else if (!pc.isAlive()) {
          healthText = "dead";
        } else {
          healthText = "drunk"; // this is a joke
        }
        view.status.pcStatus.innerHTML = pc.id + " is " + healthText
            + " and stable."
      }
    }

    function nav(screenName) {
      let screens = document.getElementsByClassName(CLASS_SCREEN);
      for (let screen of screens) {
        screen.style.display = screen.id === screenName ? "block" : "none";
      }
    }

    function timeFormat(seconds) {
      if (seconds < 0) {return "0:00";}
      let min = Math.floor(seconds / 60);
      let remainder = seconds % 60;
      let secondsZero = remainder < 10 ? "0" : "";
      return min + ":" + secondsZero + remainder;
    }

    function emptyElem(elem) {
      while(elem.hasChildNodes()) {
        elem.removeChild(elem.lastChild);
      }
    }

    function getMenuText(action) {
      // TODO make consistent?
      switch(action.type) {
        case Actions.MOVE:
          return action.target;
        case Actions.UNLOCK:
          return "Unlock Grate"; // TODO localize?
        case Actions.ATTACK:
          return "Attack " + action.target.id;
        case Actions.GET:
          return action.target.type;
        case Actions.DROP:
          return "Drop " + action.target.type;
        case Actions.USE:
          return "Use " + action.target.type;
        case Actions.CAPTURE:
          return "Catch " + action.target.id;
        case Actions.ACTIVATE:
          // TODO special text
          return "Activate " + action.target.type;
        default:
          throw new Error("Unsupported action text: " + action.type);
      }
    }

    function getEventText(event, gameData) {
        let type = event.type;
        // TODO record payload, e.g. damage, increment, etc.
        // TODO Generify, obvs

        // Hide non-visible events
        if (event.observed === Observed.NONE) { // TODO more flexible
          return null;
        }

        switch(type) {
          case Actions.MOVE:
            return event.actor.id + " moved to " + event.target + ".";
          case Actions.UNLOCK:
            return event.actor.id + " unlocked " + event.target.id + ".";
          case Actions.ATTACK:
            // TODO passive voice?
            return event.actor.id + " attacked " + event.target.id + ".";
          case Actions.GET:
            return event.actor.id + " picked up " + event.target.type + ".";
          case Actions.DROP:
            return event.actor.id + " dropped " + event.target.type + ".";
          case Actions.USE:
            return event.actor.id + " used " + event.target.type + ".";
          case Actions.CAPTURE:
            return event.actor.id + " captured " + event.target.type + ".";
          case Actions.ACTIVATE:
            return event.actor.id + " activated " + event.target.type + ".";
          case Actions.COUNT:
            return null;
          case Events.LOG:
            // TODO debug flag
            return "Log: " + target;
        }

        return "UNHANDLED EVENT:" + JSON.stringify(event);
    }

    function log(event, gameData) {
      let log = document.getElementById("events");
      let eventText
      if (event.msg) {
        eventText = event.msg;
      } else {
        eventText = getEventText(event, gameData);
      }
      if (eventText) {
        gameData.transient.view.events.events.push(eventText);
        log.innerHTML = log.innerHTML + "<span class=\"event\">"
            + eventText+ "</span><br/>";
      }
    }
  </script>
