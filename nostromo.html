<html>
  <head>
      <link rel="stylesheet" href="styles.css">
      <title>null</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
      <p id="time">Time:0</p>

      <div  class="main" style="overflow:auto;">&nbsp;
        <div id="events">&nbsp;</div>
      </div>
      <div class="menu" >menu<br/>
        move:
        <ul id="move-actions">
        </ul>
        <ul id="get-actions">
        </ul>
        <ul id="combat-actions"></ul>
      </div>
              <div id="characters" class="characters"></div>
      <div class="status">
        status&nbsp;
      </div>
  </body>
</html>

<script src="buckets.js"></script>
<script>
"use strict"

/*
TODO:
  learn css
  fix room names / IDs
  get rid of event log space
  names, like characters -> pcs
  finish map
  make movie accurate map
  make fan recreation accurate map

*/

const TICK_LENGTH = 1000;
const ACTION_MOVE = "move";
const ACTION_UNLOCK = "unlock";
const AI_PLAYER = "player";
const DEF_DEFAULT = "default";
const DEF_TYPE = "type";
const DEF_DOORS = "doors";
const SELECTED = "selected";
const MOVE_ACTIONS = "move-actions";


    function loadJSON(callback) {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', 'http://localhost:8080/nostromo.json', true);
        xobj.onreadystatechange = function () {
            if (xobj.readyState == 4 && xobj.status == "200") {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }


    loadJSON(function(response) {
        var gameData = new GameData(JSON.parse(response));
        init(gameData);
        initUi(gameData);
        setInterval(function () {
            gameLoop(gameData);
        }, TICK_LENGTH)
    });

    function init(gameData) {
        var doorDefs = gameData.getDefs(DEF_DOORS);
        for(let i in gameData.doors) {
            var door = new Door(gameData.doors[i], doorDefs);
            gameData.doors[i] = door;

            // create rooms
            for (let roomName of door.rooms) {
                if (!gameData.rooms.hasOwnProperty(roomName)) {
                    gameData.rooms[roomName] = {
                        doors:[]
                    };
                }
                var room = gameData.rooms[roomName];
                if (!room.hasOwnProperty(DEF_DOORS)) {
                  room[DEF_DOORS] = [];
                }
                gameData.rooms[roomName].doors.push(door);
            }
        }

        for(let id in gameData.rooms){
          gameData.rooms[id] = new Room(gameData.rooms[id], id)
        }
        // TODO check graph connected

        var actors = gameData.actors;
        gameData.transient.actors = {};
        for (let i in actors) {
          var actor = new Actor(actors[i]);
          actors[i] = actor;
          if (!gameData.rooms.hasOwnProperty(actor.roomName) ){
             throw new Error("actor location <" + actor.roomName + "> does not exist");
         }

         //        Check for dupes, make k-time id lookup
         if (!gameData.transient.actors.hasOwnProperty(actor.id)) {
           gameData.transient.actors[actor.id] = actor;
         } else {
           throw new Error("Duplicate actor id " + actor.id);
         }
        }


        var scheduler = buckets.PriorityQueue(function(a, b){
            // TODO unit test
            return b.time - a.time;
        });
        gameData.scheduler = scheduler;
    }

    function gameLoop(gameData) {
        document.getElementById("time").innerHTML = ("Time:" + gameData.time);
        var eventBus = []
        var scheduler = gameData.scheduler;

        // TODO copy gamedata
        // Handle scheduled events
        while (!scheduler.isEmpty() && scheduler.peek().time <= gameData.time) {
            eventBus.push(scheduler.dequeue());
        }
        for (let event of eventBus) {
            handleAction(event, gameData);
        }

       // Queue new actions
        var busyActors = scheduler.toArray().map((a)=>a.actor.name); // TODO non-actors
        for (let actor of gameData.actors) {
            if (!busyActors.includes(actor.name)) {
                // AI actions
                // TODO Different supported actions by actor
                var choices = getChoices(actor, gameData);
                if (actor.ai != AI_PLAYER) {

                    // TODO Specific AIs

                    takeAction(actor, choices[Math.floor(Math.random() * choices.length)], gameData); // TODO Types

                } else {
                     // TODO handle input
                }
            }
        }

        // TODO cleanup, maintenance (?)
       gameData.time = gameData.time + 1;
    }

    function handleAction(event, gameData) {
        if (event.type === ACTION_MOVE) {
            event.actor.roomName = event.target
        } else if (event.type === ACTION_UNLOCK) {
            event.target.locked = false;
        }
        var log = document.getElementById("events");
        log.innerHTML= log.innerHTML + (eventText(event, gameData) + "<br/>");
    }

    function takeAction(actor, action, gameData) { // todo rename queue
        var length = 5; // TODO ??
        action.time = gameData.time + length;
        gameData.scheduler.enqueue(action);
    }

    function eventText(event, gameData) {
        var type = event.type;
        if (type === ACTION_MOVE) {
            return event.actor.name + " moved to " + event.target + ".";
        }
        if (type === ACTION_UNLOCK) {
            return event.actor.name + " unlocked " + event.target.toString() + ".";
        }
        return "UNHANDLED EVENT:" + JSON.stringify(event);
    }

    function getChoices(actor, gameData) {
        var out = [];
        var room = gameData.rooms[actor.roomName];
        for (let door of room.doors) {
            if (!door.locked) {
                out.push(new Action(ACTION_MOVE, door.other(room.name), actor));
            } else {
              // TODO If actor supported
                out.push(new Action(ACTION_UNLOCK, door, actor));
            }
        }
        return out;
    }

    function initUi(gameData) {
      // Cache view
      var view = {};
      gameData.transient.view = view;
      view.pcTabs = {};

      // character tabs
      var charTabs = document.getElementById("characters");
      for (let pc of gameData.getPcs()) {
        var newButton = document.createElement("BUTTON");
        newButton.innerHTML = pc.name;
        newButton.onclick=function(){
          selectPc(pc.name, gameData);
          draw(gameData);
        };
        charTabs.appendChild(newButton);
        view.pcTabs[pc.name] = newButton;
      }

      view.moves = document.getElementById(MOVE_ACTIONS);

      // Validate
      for (let subview in view) {
        if (view[subview] === undefined || view[subview] === null) {
          throw Error("Empty view handle " + subview);
        }
      }
    }

    function selectPc(pcId, gameData) {
      gameData.selected = pcId;
    }

    function draw(gameData) {
      var view = gameData.transient.view;
      // PC tabs
      for (let pcId in view.pcTabs) {
        var tab = view.pcTabs[pcId];
        if (gameData.selected === pcId) {
          tab.style.color = "green";
        } else {
          tab.style.color = "black";
        }
      }

      // menu
      if(gameData.pcSelected()) {
        var pc = gameData.getActor(gameData.selected);
        var choices = getChoices(pc, gameData);
        var choicesByType = Action.byType(choices);
        // Move actions
        var moveView = view.moves;
        emptyElem(moveView);
        if (choicesByType.hasOwnProperty(ACTION_MOVE)) {
          var moveActions = choicesByType[ACTION_MOVE];
          for (let move of moveActions) {
            moveView.innerHTML = moveView.innerHTML
                + "<li>" + move.getMenuText() + "</li>"
          }

        }
      }

    }

    function emptyElem(elem) {
      while(elem.hasChildNodes()) {
        elem.removeChild(elem.lastChild);
      }
    }

    class GameData {
      constructor(json) {
        Object.assign(this, json);
        this.transient = {};
      }

      getDefs(defType) {
        if(this.defs.hasOwnProperty(defType)) {
            return this.defs[defType];
        }
        throw Error("No defs type '" + defType + "'.")
      }

      getPcs() {
        return this.actors.filter(actor => actor.ai === AI_PLAYER);
      }

      pcSelected() {
        return this.hasOwnProperty(SELECTED) && this.selected != undefined
            && this.selected != null;
      }

      getActor(id) {
        if (this.transient.actors.hasOwnProperty(id)) {
          return this.transient.actors[id];
        }
        throw Error("No actor with id " + id);
      }
    }

    class Actor {
      constructor(json) {
        Object.assign(this, json);
        if (this.name === undefined) {
          this.name = this.id;
        } else if (this.id ===undefined) {
          this.id = this.name;
        }
        if (this.id === undefined) {
          throw Error("Actor has no id or name");
        }
        // TODO default or require: inventory, attack
        // TODO random location option
        if (!this.hasOwnProperty("roomName")) {
            throw new Error("No location:" + JSON.stringify(actor));
        }
      }
    }

    class Action {
        constructor(type, target, actor) {
            this.type = type;
            this.target = target;
            this.actor = actor;
        }

        static byType(actions) {
          var aggregate = {};
          for (let next of actions){
            if (!next.hasOwnProperty(DEF_TYPE)) {
              throw Error("Typeless action in byType()");
            }
            if(!aggregate.hasOwnProperty(next.type)) {
              aggregate[next.type] = [];
            }
            aggregate[next.type].push(next);
          }
          return aggregate;
          }

        getMenuText() {
          // TODO make consistent?
          switch(this.type) {
            case ACTION_MOVE:
              return this.target;
            case ACTION_UNLOCK:
              return "Unlock Grate"; // TODO localize?
            default:
              throw new Error("Unsupported action text: " + this.type);
          }
        }
    }

    class TypedClass {

        constructor(json, typeDefs) {
            // Assign characteristics hierarchically
            if (typeDefs.hasOwnProperty(DEF_DEFAULT)) {  // Type default
                Object.assign(this, typeDefs[DEF_DEFAULT]);
            }
            if (json.hasOwnProperty(DEF_TYPE)) { // Specific type
                var jsonType = json[DEF_TYPE];
                if (typeDefs.hasOwnProperty(jsonType)) {
                    Object.assign(this, typeDefs[jsonType]);
                } else {
                    throw Error("No defined type: " + jsonType);
                }
            }
            Object.assign(this, json); // Specific instance
        }
    }

    class Room {
      constructor(json, roomId) {
        // decalre empty lists
        this.doors = [];
        this.special = [];
        // Apply args
        Object.assign(this, json);
        this.id = roomId;
        if(!this.hasOwnProperty("name")) {
          this.name = this.id;
        }
      }

      links(){
          var out = [];
          for (let door of this.doors) {
              out.push(door.other(this.name));
          }
          return out;

          //TODO dspecial and addDoora
      }};

    class Door extends TypedClass {
        constructor(json, typeDefs) {
            super(json, typeDefs);
            if (this.rooms.length != 2) {
                throw new Error("door with " + this.rooms.length + " rooms");
            }
        }

        other(roomName) { // TODO declare elsewwhere
            if (this.rooms[0] === roomName) {
                return this.rooms[1];
            }
            if (this.rooms[1] === roomName) {
                return this.rooms[0];
            }
           throw new Error("room <" + roomName + "> not in doors");
        }

        toString() {
            return "Door[" + this.rooms[0] + "/" + this.rooms[1] + "]";
        }
    }

    // TODO actor class here


    //alert( 'Hello, world!' + makeData(23, 15, 10, 0.5));

    /*
    "actors": {
      "Ripley":{
        "ai": "player",
        "roomName": "bridge"
      },
      "Parker":{
        "ai": "player",
        "roomName": "bridge"
      },
      "Lambert":{
        "name": "",
        "ai": "player",
        "roomName": "bridge"
      },
      "Alien":{
        "ai": "classic",
        "inventory": 0,
        "roomName": "shuttle bay"
      },
      "Cat":{
        "name": "",
        "ai": "wander",
        "inventory": 0,
        "small": true,
        "roomName": "corridor2"
      }
    },


    */
  </script>
