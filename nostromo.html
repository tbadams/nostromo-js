<html>
  <head>
      <link rel="stylesheet" href="styles.css">
      <title>null</title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <p id="topBar">
      <span id="time">Time:0</span>
      <span id="oxygen"></span>
    </p>

      <div  class="main" style="overflow:auto;">&nbsp;
        <div id="events">&nbsp;</div>
      </div>
      <div class="menu" >menu<br/>
        move:
        <div id="move-actions">
        </div>
        Get:
        <div id="get-actions"></div>
        Combat:
        <div id="combat-actions"></div>
        Other:
        <div id="other-actions"></div>
      </div>
              <div id="characters"></div>
      <div class="status">
        status&nbsp;
        <div id="room-line">
          <span id="room-name"></span>
          <span id="room-health"></span>
        </div>
        <div id="pc-status"></div>
        <div id="room-description"></div>
      </div>
  </body>
</html>

<script src="buckets.js"></script>
<script>
"use strict"

/*
TODO:
actions have speed
SEPERATE GODDAMN FILES
move category into TypedClass
refine selectors
  miss chance
  wound logs (and miss) as seprate event
  show pending action
  acid blood
  all interobject refs through IDs, no references
  replace void room with item/actor/etc. "rooms"
    generic item action code
  ai system
  widgets and service
  split htm and js
  get rid of event log space
  names, like characters -> pcs
  deep copy def obj (?)
  scopable event log
  add 'config' object, mostly for debugging
    disable clicking on dead pc tab
  upside down event log?
  generate js signature docs
  map display
  finish map
  make movie accurate map
  make fan recreation accurate map
  json case insensitive?
  pending action progress bar
fix stupid json error catching code
localization??
*/

const TICK_LENGTH = 1000;
const Actions = {
  MOVE:"move",
  UNLOCK:"unlock",
  ATTACK:"attack",
  GET:"get",
  DROP:"drop",
  USE:"use",
  CAPTURE:"capture",  // TODO generic target action
  COUNT:"count"
};
const Events = {
  LOG:"log"
};
const Category = {
  DOORS:"doors",
  ITEMS:"items",
  ACTORS:"actors",
  ROOMS:"rooms",
  SPECIAL:"special"
};
const Health = {
  OK:"OK",
  WOUNDED:"wounded",
  DEAD:"dead"
};
const AI_PLAYER = "player";
const DEF_DEFAULT = "default";
const DEF_TYPE = "type";
const SELECTED = "selected";
const MOVE_ACTIONS = "move-actions";
const GET_ACTIONS = "get-actions";
const COMBAT_ACTIONS = "combat-actions";
const OTHER_ACTIONS = "other-actions";
const VOID = "void"; // Room for when need "nowhere"
const CATEGORY_ALL = "all";
const OXYGEN = "oxygen";


    function loadJSON(callback) {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', 'http://localhost:8080/nostromo.json', true);
        xobj.onreadystatechange = function () {
            if (xobj.readyState == 4 && xobj.status == "200") {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }

    loadJSON(function(response) {
        let errorPattern = /(\d+).*/g;
        var parsed;
        try {
          parsed = JSON.parse(response);
        } catch (e) {
          if (e instanceof SyntaxError) {
            const grabRadius = 20;
              let message = e.message;
              let matched =  errorPattern.exec(message);
              let pos = matched[1]; // 1st capture
              if (pos) {
                let min = Math.max(0, pos - grabRadius);
                let max = Math.min(response.length - 1, pos + grabRadius);
                let snippet = response.substring(min, pos)
                    + ">HERE<" + response.substring(pos, max);
                alert( 'Error loading game data JSON: ' + e + '\n\n' + snippet);
              }
          } else {
            alert('Error: ' + e);
          }
          return;
        }
        var gameData = new GameData(parsed);
        init(gameData);
        initUi(gameData);
        setInterval(function () {
            gameLoop(gameData);
        }, TICK_LENGTH);
    });

    function init(gameData) {
      if (!gameData.state) {
        // Extra initialization for first ever run
        gameData.state = {
          time:0,
          paused:false
        }
        // Generate implied rooms from doors
        // Get the list of door ids for every room
        let roomDoorMap = {};
        gameData.rooms.push({id: VOID, doorIds:[]}); // VOID room, for taking things out of level
        for (let i in gameData.doors) {
          gameData.doors[i] = new Door(gameData.doors[i], gameData.defs.doors, i);
          let door = gameData.doors[i];
          for (let roomName of door.rooms) {
              if (!roomDoorMap.hasOwnProperty(roomName)) {
                  roomDoorMap[roomName] = {
                    id:roomName,
                      doorIds:[]
                  };
              }
              roomDoorMap[roomName].doorIds.push(door.id);
          }
        }
        // Assign door id lists to rooms that already exist
        for (let room of gameData.rooms) {
          if (roomDoorMap[room.id] && roomDoorMap[room.id].doorIds) {
            room.doorIds = roomDoorMap[room.id].doorIds;
            delete roomDoorMap[room.id];
          }
        }
        // Create remaining ("implied") ROOMS
        for (let roomName in roomDoorMap) {
          gameData.rooms.push(roomDoorMap[roomName]);
        }

        // Grab objects nested in others, extract to top level
        for (let category of asList(Category)) {
          let objects = gameData[category];
          for (let object of objects) {
            for (let category2 of asList(Category)){
              if (!gameData[category2]) {
                gameData[category2] = [];
              }
              if (object[category2] && category2 != Category.ROOMS) { // nothing can contain rooms... yet
                if (!object.id) {throw Error("no id");}
                for ( let contained of object[category2]) {
                  contained.roomName = object.id; // TODO Generify
                  gameData[category2].push(contained);
                }
                delete object[category2];
              }
            }
          }
        }
      }

      // Actual game initialization
      let lookupAll = {}
      gameData.transient.byId.all = lookupAll;

      for (let key in Category ) {
        let category = Category[key];
        let defs = gameData.defs[category];
        let itemDefs = gameData.defs[Category.ITEMS];
        let objects = gameData[category];
        let lookup = {};
        gameData.transient.byId[category] = lookup;

        for (let i in objects) { // Instantiation pass
          objects[i] = TypedClass.create(category, objects[i], defs, i);
          let object = objects[i];
          if (lookup[object.id] || lookupAll[object.id]) {
            throw Error("Dupe id " + object.id);
          }
          lookup[object.id] = object;
          lookupAll[object.id] = object;
        }
      }

        // TODO check graph connected

        // validate each contained has valid container, set up mem references
        let all = gameData.transient.byId.all;
        for (let i in all) {
          let thing = all[i]
          if (thing.roomName) { // TODO generify
            if (!gameData.getByCategoryId(Category.ROOMS, thing.roomName)){
               throw new Error("thing location <" + thing.roomName + "> does not exist");
             } else {
                // inform parent
                let parent = all[thing.roomName];
                let cat = thing.category;
                if (!parent.transient[cat]) {
                  parent.transient[cat] = [];
                }
                parent.transient[cat].push(thing);
             }
           }
        }

        if (!gameData.scheduler) {
          gameData.scheduler = buckets.PriorityQueue(function(a, b){
              // TODO unit test
              return b.time - a.time;
          });
        } else {
          // TODO
          throw new Error("Scheduler persistence not implemented");
        }
    }

    function gameLoop(gameData) {
        var eventBus = []
        var scheduler = gameData.scheduler;

        // TODO copy gamedata
        // Handle scheduled events
        while (!scheduler.isEmpty() && scheduler.peek().time <= gameData.state.time) {
            eventBus.push(scheduler.dequeue());
        }
        // check validity *before* resolving any Actions
        eventBus = eventBus.filter(event=>event.isValid(gameData));
        for (let event of eventBus) {
            Action.handleAction(event, gameData);
        }

       // Queue new actions
        for (let actor of gameData.getAll()) {
          // not preoccupied doing something, like being dead or in a box
            if (actor.takesActions() && !gameData.isBusy(actor.id)) {
                var choices = Action.getChoices(actor, gameData);
                // AI actions
                if (actor.ai != AI_PLAYER) {
                    // TODO Specific AIs
                    if (choices.length > 0) {
                      Action.takeAction(actor, choices[Math.floor(Math.random() * choices.length)], gameData); // TODO Types
                    }
                } else {
                     // TODO handle input
                }
            }
        }

        // cull newly invalid actions
        let contents = scheduler.toArray();
        contents = contents.filter((action)=>action.isValid(gameData));
        scheduler.clear();
        for(let action of contents) {
          scheduler.add(action);
        }
        // TODO cleanup, maintenance (?)
       gameData.state.time = gameData.state.time + 1;

       draw(gameData);
    }

    function initUi(gameData) {
      // Cache view
      var view = {};
      gameData.transient.view = view;
      view.pcTabs = {};

      // character tabs
      var charTabs = document.getElementById("characters");
      for (let pc of gameData.getPcs()) {
        var newButton = document.createElement("BUTTON");
        newButton.innerHTML = pc.id;
        newButton.onclick=function(){
          selectPc(pc.id, gameData);
          draw(gameData);
        };
        charTabs.appendChild(newButton);
        view.pcTabs[pc.id] = newButton;
      }

      view.menu = {};
      view.menu.moves = document.getElementById(MOVE_ACTIONS);
      view.menu.gets = document.getElementById(GET_ACTIONS);
      view.menu.combat = document.getElementById(COMBAT_ACTIONS);
      view.menu.other = document.getElementById(OTHER_ACTIONS);

      view.status = {}
      view.status.roomName = document.getElementById("room-name");
      view.status.roomHealth = document.getElementById("room-health");
      view.status.pcStatus = document.getElementById("pc-status");
      view.status.roomDescription = document.getElementById("room-description");

      // Validate
      validateView(view);
    }

    function validateView(view) {
      for (let key in view) {
        let subview = view[key];
        if (!subview) {
          throw Error("Empty view handle " + subview);
        }
        for (let subkey in subview) {
          let subsubview = subview[subkey];
          if (!subsubview) {
            throw Error("Empty subview handle " + subview);
          }
        }
      }
    }

    function selectPc(pcId, gameData) {
      let pc = gameData.getByCategoryId(Category.ACTORS, pcId);
      if (pc.ai === AI_PLAYER && pc.isAlive()) {
        gameData.selected = pcId; // TODO rename selectedId
      } else {
        gameData.selected = null;
      }
    }

    function asList(enumeration){
      let out = [];
      for (let k in enumeration) {
        out.push(enumeration[k]);
      }
      return out;
    }

    function draw(gameData) {
      var view = gameData.transient.view;

      // Top bar
      document.getElementById("time").innerHTML = ("Time:" + gameData.state.time);
      let oxygen = gameData.getByCategoryId(CATEGORY_ALL, OXYGEN);
      if (oxygen) {
        document.getElementById(OXYGEN).innerHTML = ("Oxygen:" + oxygen.count);
      }


      // PC tabs
      for (let pcId in view.pcTabs) {
        var tab = view.pcTabs[pcId];
        if (gameData.selected === pcId) {
          tab.style.color = "green";
        } else {
          tab.style.color = "black";
          if (!gameData.getByCategoryId(Category.ACTORS, pcId).isAlive()) {
            tab.style.opacity = 0.6;
          }
        }
      }

      // menu & status
      let menu = view.menu;
      for(let subview in menu) {
        emptyElem(menu[subview]);
      }
      let status = view.status;
      for (let key in status) {
        emptyElem(status[key]);
      }
      if(gameData.pcSelected()) {
        var pc = gameData.getByCategoryId(Category.ACTORS, gameData.selected);
        var choices = Action.getChoices(pc, gameData);
        // Move actions

        if (pc.isAlive() && !gameData.isBusy(pc.id)) {
          for(let action of choices) {
            var newButton = document.createElement("BUTTON");
            newButton.innerHTML = action.getMenuText();
            newButton.onclick=function(){
              Action.takeAction(pc, action, gameData)
              draw(gameData);
            };
            switch(action.type) {
              case Actions.MOVE:
                view.menu.moves.appendChild(newButton);
                break;
              case Actions.GET:
                view.menu.gets.appendChild(newButton);
                break;
              case Actions.ATTACK:
                view.menu.combat.appendChild(newButton);
                break;
              default:
                view.menu.other.appendChild(newButton);
                break;
            }

          }
        } // else busy

        // status
        let room = gameData.getByCategoryId(Category.ROOMS, pc.roomName);
        view.status.roomName.innerHTML = room.id;
        view.status.roomHealth.innerHTML = room.health + "%";
        let healthText;
        if (pc.hp > pc.health / 2) {
          healthText = "OK";
        } else if (pc.hp > 0) {
          healthText = "wounded";
        } else if (!pc.isAlive()) {
          healthText = "dead";
        } else {
          healthText = "drunk";
        }
        view.status.pcStatus.innerHTML = pc.id + " is " + healthText
            + " and stable."
      }
    }

    function emptyElem(elem) {
      while(elem.hasChildNodes()) {
        elem.removeChild(elem.lastChild);
      }
    }

    class GameData {
      constructor(json) {
        Object.assign(this, json);
        this.transient = {};
        this.transient.byId = {};
      }

      getDefs(defType) {
        if(this.defs.hasOwnProperty(defType)) {
            return this.defs[defType];
        }
        throw Error("No defs type '" + defType + "'.")
      }

      getAll() {
        return asList(this.getCategoryMap(CATEGORY_ALL));
      }

      getCategoryMap(category) {
        return this.transient.byId[category];
      }

      getByCategoryId(category, id) {
        return this.transient.byId[category][id];
      }

      getPcs() {
        return this.actors.filter(actor => actor.ai === AI_PLAYER);
      }

      pcSelected() { // TODO selectedId
        return this.selected && this.getByCategoryId(Category.ACTORS, this.selected).isAlive();
      }

      isBusy(actorId) {
        var busyActors = this.scheduler.toArray().map((a)=>a.actor.id); // TODO non-actors
        return busyActors.includes(actorId);
      }
    }

    class Action {
        constructor(type, target, actor, duration, required) { // TODO swap target and actor
            this.type = type;
            this.target = target;
            this.actor = actor;
            if (!duration) {
              // TODO Something else
              this.duration = 5;
            } else {
              this.duration = duration;
            }

            this.source = actor.getActionMap()[type];

            for (let requirement of ["type", "actor"]) {
              if (!this[requirement]) {
                throw new Error("field" + requirement + " must be non null for type Action");
              }
            }
        }

        static byType(actions) {
          var aggregate = {};
          for (let next of actions){
            if (!next.hasOwnProperty(DEF_TYPE)) {
              throw Error("Typeless action in byType()");
            }
            if(!aggregate.hasOwnProperty(next.type)) {
              aggregate[next.type] = [];
            }
            aggregate[next.type].push(next);
          }
          return aggregate;
        }

        static getChoices(actor, gameData) {
            let out = [];
            let room = gameData.getByCategoryId(Category.ROOMS, actor.roomName);
            let actionMap = actor.getActionMap();
            let addIfSupported = (action)=>{
              if (actionMap[action.type] && action.isValid(gameData)) {
                out.push(action);
              }
            }
            if (room) {
              if(room.getItems() && actor.getItems().length < actor.inventory) {
                let items = room.getItems();
                for (let item of items) {
                  addIfSupported(new Action(Actions.GET, item, actor));
                }
              }
              for (let doorId of room.doorIds) {
                let door = gameData.getByCategoryId(Category.DOORS, doorId)
                  if (!door.locked) {
                    addIfSupported(new Action(Actions.MOVE, door.other(room.id), actor));
                  } else {
                    // TODO If actor supported
                    addIfSupported(new Action(Actions.UNLOCK, door, actor));
                  }
              }
            }

            // Combat
            let actorsHere = [];
            for (let otherActor of gameData.actors ) {
              if (otherActor.roomName === actor.roomName
                  && otherActor.id != actor.id) {
                  addIfSupported(new Action(Actions.ATTACK, otherActor, actor));
                  addIfSupported(new Action(Actions.CAPTURE, otherActor, actor));
              }
            }

            // Items
            if (actor.getItems()) {
              let items = actor.getItems();
              for (let item of items) {
                // addIfSupported(new Action(Actions.USE, item, actor));
                addIfSupported(new Action(Actions.DROP, item, actor));
              }
            }

            // For logic actors
            addIfSupported(new Action(Actions.COUNT, null, actor, 1));

            return out;
        }

        static handleAction(event, gameData) {
            let effects = [];
            let actor = event.actor;
            let actorRoom = gameData
                .getByCategoryId(Category.ROOMS, event.actor.roomName);
            let target = event.target;
            if (event.type === Actions.MOVE) {
                event.actor.roomName = event.target;
                // TODO fucking move fuck tshit ass
            } else if (event.type === Actions.UNLOCK) {
                event.target.locked = false;
            } else if (event.type === Actions.ATTACK) {
                let weapon = event.source;
                let targetWasAlive = target.isAlive();
                if (weapon) {
                  target.hp -= weapon.damage;
                  effects.push({msg:target.id + " is being wounded."}); // TODO ??? not OK??
                  if(!weapon.nobleed) {
                    // TODO bleed
                  }
                  if (targetWasAlive && !target.isAlive()) {
                    effects.push({msg: target.id + " has collapsed."});
                  }
                }
            } else if (event.type === Actions.GET) {
              let item = event.target;
              item.roomName = actor.id; // TODO do... something else
              actorRoom.transient.items = actorRoom.getItems().filter((thing)=>thing != item);
                event.actor.transient.items.push(event.target);
            } else if (event.type === Actions.DROP) {
              // Move item to room
              let item = event.target;
              item.roomName = actorRoom.id;
              event.actor.transient.items = event.actor.getItems().filter((thing)=>thing != item);
              actorRoom.transient.items.push(item);
            } else if (event.type === Actions.USE) {
              // TODO ...use it
            } else if (event.type === Actions.CAPTURE) {
              event.source.captive = target;
              target.roomName = VOID;
              gameData.actors.splice(gameData.actors.indexOf(target));
            } else if (event.type === Actions.COUNT) {
              actor.increment(gameData);
            } else {
              throw Error("undefined action " + event)
            }
            this.log(event, gameData);
            for (let effect of effects) {
              this.log(effect, gameData);
            }
        }

        static log(event, gameData) {
          var log = document.getElementById("events");
          if (event.msg) {
            log.innerHTML = log.innerHTML + event.msg + "<br/>";
          } else {
            let eventText = event.getEventText(gameData);
            if (eventText) {
              log.innerHTML= log.innerHTML + (eventText + "<br/>");
            }
          }
        }

        static takeAction(actor, action, gameData) { // todo rename queue
            if (action.isValid(gameData)) {
              action.time = gameData.state.time + action.duration;
              gameData.scheduler.enqueue(action);
            } else {
              gameData.scheduler.enqueue(new Action(Events.LOG, "invalid action taken", 0));
            }
        }

        isValid(gameData) {
          if (!gameData) {throw new Error("NO MORE NULL GAMEDATA");}
          let actor = this.actor;
          let actionMap = actor.getActionMap();
          if (!actionMap[this.type]) {
            return false;
          }
          let target = this.target;
          let actorRoom = gameData
              .getByCategoryId(Category.ROOMS, actor.roomName);
          switch(this.type) {
            case Actions.MOVE: // target=roomName
              return actorRoom.getLinks(gameData).includes(target);
            case Actions.UNLOCK: // target=door object
              return target.rooms.includes(actor.roomName);
            case Actions.ATTACK: // actor object
              return actor.roomName === target.roomName && target.attackable
                  && target.isAlive();
            case Actions.CAPTURE: // actor object
              return actor.roomName === target.roomName
                  && target.capturable && !actionMap[this.type].captive;
            case Actions.GET: // room item
              return actorRoom.getItems().includes(target)
                && actor.getItems().length < actor.inventory;
            case Actions.DROP: // actor item
              return actor.getItems().includes(target);
            case Actions.USE:
              return (actorRoom.getItems().includes(target) || actor.getItems().includes(target))
                  && target.isUsable();
            case Actions.COUNT:
            case Events.LOG:
              return true;
            default:
              throw new Error("Unsupported action validation: " + this.type);
          }
        }

        getMenuText() {
          // TODO make consistent?
          switch(this.type) {
            case Actions.MOVE:
              return this.target;
            case Actions.UNLOCK:
              return "Unlock Grate"; // TODO localize?
            case Actions.ATTACK:
              return "Attack " + this.target.id;
            case Actions.GET:
              return this.target.type;
            case Actions.DROP:
              return "Drop " + this.target.type;
            case Actions.USE:
              return "Use " + this.target.type;
            case Actions.CAPTURE:
              return "Catch " + this.target.id;
            default:
              throw new Error("Unsupported action text: " + this.type);
          }
        }

        getEventText(gameData) {
            let type = this.type;
            // TODO record payload, e.g. damage, increment, etc.
            switch(type) {
              case Actions.MOVE:
                return this.actor.id + " moved to " + this.target + ".";
              case Actions.UNLOCK:
                return this.actor.id + " unlocked " + this.target.id + ".";
              case Actions.ATTACK:
                // TODO passive voice?
                return this.actor.id + " attacked " + this.target.id + ".";
              case Actions.GET:
                return this.actor.id + " picked up " + this.target.type + ".";
              case Actions.DROP:
                return this.actor.id + " dropped " + this.target.type + ".";
              case Actions.USE:
                return this.actor.id + " used " + this.target.type + ".";
              case Actions.CAPTURE:
                return this.actor.id + " captured " + this.target.type + ".";
              case Actions.COUNT:
                return null;
              case Events.LOG:
                // TODO debug flag
                return "Log: " + target;
            }

            return "UNHANDLED EVENT:" + JSON.stringify(event);
        }
    }

    class TypedClass {

        constructor(json, typeDefs, id, requirements) {
            // Assign characteristics hierarchically
            this.id = id; // Prefer id from data
            if (typeDefs.hasOwnProperty(DEF_DEFAULT)) {  // Type default
                Object.assign(this, typeDefs[DEF_DEFAULT]);
                this.type = DEF_DEFAULT;
            }
            if (json.hasOwnProperty(DEF_TYPE)) { // Specific type
                var jsonType = json[DEF_TYPE];
                if (typeDefs.hasOwnProperty(jsonType)) {
                    Object.assign(this, typeDefs[jsonType]);
                } else {
                    throw Error("No defined type: " + jsonType);
                }
            }
            Object.assign(this, json); // Specific instance
            this.transient = {};
            this.transient.items = [];

            // Validate common properties
            if (!requirements) {
              requirements = [];
            }
            // TODO set category in constructor, validate here
            let mergedRequirements = requirements.concat(
              ["id", "type"])
            for (let req of mergedRequirements) {
              if (!this[req]) {
                throw Error("Typed object is missing required field " + req);
              }
            }
        }

        takesActions() {return this.ai}

        getContained(category) {
          return this.transient[category];
        }

        getItems() {
          if (!this.transient.items) {return [];}

          return this.getContained(Category.ITEMS);
        }

        getActionMap(){ // make map of actions to source
          if (!this.actions) {
            throw Error(id + " has no actionMap")
          }
          let tempOut = {};

          for (let action of this.actions) {
            tempOut[action] = this;
          }
          if (this.getItems()[0]) {
            for (let action of this.getItems()[0].actions) {
              tempOut[action] = this.getItems()[0]; // TODO collision
            }
          }
          return tempOut;
        }

        static create(category, json, def, id) {
          switch(category) {
            case Category.ACTORS:
              return new Actor(json, def, id);
            case Category.DOORS:
              return new Door(json, def, id);
            case Category.SPECIAL:
              return new Special(json, def, id);
            case Category.ITEMS:
              return new Item(json, def, id);
            case Category.ROOMS:
              return new Room(json, def, id);
            default:
              throw new Error("Unsupported category " + category);
          }
        }
    }

    class Actor extends TypedClass {
      constructor(json, defs) {
        super(json, defs);
        this.category = Category.ACTORS;

        // TODO default or require: inventory, attack
        // TODO random location option
        let required = ["roomName", "actions"];
        for (let req of required) {
          if (!this.hasOwnProperty(req)) {
              throw new Error("No value for " + req + ": "
                  + JSON.stringify(actor));
          }
        }

        if (!this.hp) {
          this.hp = this.health;
        }
      }

      takesActions() {
        return super.takesActions() && this.isAlive();
      }

      isAlive() {
        return this.hp > 0;
      }
    }

    class Room extends TypedClass {
      constructor(json, defs, id) {
        super(json, defs, id)
        this.category = Category.ROOMS;
        // declare default variables
        if (!this.doorIds) {this.doorIds = [];}
        if (!this.special) {this.special = [];}
      }

      getLinks(gameData){
          var out = [];
          for (let doorId of this.doorIds) {
            let door = gameData.getByCategoryId(Category.DOORS, doorId);
              out.push(door.other(this.id));
          }
          return out;

          //TODO dspecial and addDoora
      }};

    class Door extends TypedClass {
        constructor(json, typeDefs, id) {
            super(json, typeDefs, "door" + id);
            this.category = Category.DOORS;
            if (this.rooms.length != 2) {
                throw new Error("door with " + this.rooms.length + " rooms");
            }
        }

        other(roomName) { // TODO declare elsewwhere
            if (this.rooms[0] === roomName) {
                return this.rooms[1];
            }
            if (this.rooms[1] === roomName) {
                return this.rooms[0];
            }
           throw new Error("room <" + roomName + "> not in doors");
        }
    }

    class Item extends TypedClass {
      constructor(json, typedefs, id) {
        super(json, typedefs, "item" + id);
        this.category = Category.ITEMS;
        if (!this.actions) {
          this.actions = [];
        }

        if (this.damage) {
          this.actions.push(Actions.ATTACK);
        }

        if (this.hasOwnProperty("captive")) {
          this.actions.push(Actions.CAPTURE);
        }

      }

      isUsable() {
        // weapons dpon't count
        return this.actions.length > 0;
      }
    }

    class Special extends TypedClass {
      constructor (json, typeDefs, id) {
        super(json, typeDefs, "special" + id);
        this.category = Category.SPECIAL;

        if (this.count) {
          this.incrementVal = new Selector(this.incrementVal);
        }
      }

      increment(gameData) {
        // TODO plus or minus
        let vals = this.incrementVal.getVals(gameData);
        let inc = vals.length * 2;
        this.count = this.count - inc;
      }

    }

    class Selector {
      constructor (json) {
        if (!json) {
          throw Error ("No value to wrap");
        }
        this.json = json;
      }

      // Return wrapped int value, or use selector object to find referenced value(s)
      getVals(gameData) {
        return gameData.getAll().filter(obj=>{
          for (let field in this.json) {
            if (!obj[field] || !(obj[field] === this.json[field])) {
              return false;
            }
          }
          return true;
        });
      }
    }



  </script>
